<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cellular Seance v.95.5</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Special+Elite&family=VT323&family=Roboto+Mono&family=UnifrakturMaguntia&display=swap" rel="stylesheet">
  <style>
      /* --- Base & Body --- */
      html, body {
          overscroll-behavior: none;
          touch-action: manipulation;
          width: 100%;
          height: 100%;
          overflow: hidden;
          background-color: #0a0a0a;
      }
      body {
          font-family: 'Inter', sans-serif;
          color: #e0e0e0;
      }
      .special-elite { font-family: 'Special Elite', cursive; }
      .vt323 { font-family: 'VT323', monospace; }
      .roboto-mono { font-family: 'Roboto Mono', monospace; }
      .unifrakturmaguntia { font-family: 'UnifrakturMaguntia', cursive; }

      /* --- NEW: Loading and Title Screen --- */
      #loading-overlay {
          position: fixed;
          inset: 0;
          background-color: #000000;
          z-index: 9999;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: opacity 0.5s ease-out;
      }
      #loading-bar-container {
          width: 50%;
          max-width: 400px;
          height: 10px;
          border: 1px solid white;
      }
      #loading-bar {
          width: 0%;
          height: 100%;
          background-color: white;
          animation: fill-bar 0.5s ease-out forwards;
      }
      @keyframes fill-bar {
          from { width: 0%; }
          to { width: 100%; }
      }
      #title-screen-overlay {
          position: fixed;
          inset: 0;
          background-color: rgba(10, 10, 10, 0.85);
          backdrop-filter: blur(8px);
          z-index: 9998;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          text-align: center;
          padding: 2rem;
          opacity: 1;
          transition: opacity 0.5s ease-in-out;
      }
      #title-screen-overlay.hidden {
          opacity: 0;
          pointer-events: none;
      }
      .title-header {
          font-family: 'Special Elite', cursive;
          font-size: 3rem;
          color: #e0e0e0;
          text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
          margin-bottom: 1.5rem;
      }
      .start-button {
          font-family: 'VT323', monospace;
          font-size: 1.5rem;
          padding: 0.75rem 2rem;
          background-color: rgba(255, 255, 255, 0.1);
          border: 1px solid #777;
          border-radius: 4px;
          color: white;
          cursor: pointer;
          transition: all 0.2s ease-in-out;
          margin-bottom: 2rem;
      }
      .start-button:hover {
          background-color: rgba(255, 255, 255, 0.2);
          border-color: #aaa;
      }
      .about-section {
          max-width: 600px;
          color: #a0aec0;
          font-size: 0.9rem;
          line-height: 1.5;
      }
      
      /* --- Main App Layout --- */
      #app-container {
          position: fixed;
          inset: 0;
          display: flex;
          flex-direction: column;
          background-color: #0a0a0a;
          transition: padding-bottom 0.4s ease-in-out; /* Add transition for padding */
      }
      #simulationContainer {
          flex-grow: 1;
          position: relative;
          overflow: hidden;
      }
      #simulationCanvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          cursor: grab;
      }
      #simulationCanvas.brush-active {
          cursor: crosshair;
      }
      #simulationCanvas:active {
          cursor: grabbing;
      }
      #simulationCanvas.brush-active:active {
          cursor: crosshair;
      }


      /* --- CRT Glow Effect --- */
      #crt-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 10;
          border-radius: 2em; /* Emulate screen curve */
          box-shadow: inset 0 0 2em 0.5em rgba(0,0,0,0.5);
      }
      
      /* --- Floating Main Controls --- */
      #main-controls {
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 100;
          display: flex;
          gap: 8px;
          padding: 8px;
          background-color: rgba(18, 18, 18, 0.8);
          backdrop-filter: blur(10px);
          border: 1px solid #444;
          border-radius: 9999px;
          box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
          transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
      }
      
      #main-controls.hidden {
          opacity: 0;
          pointer-events: none;
          transform: translateX(-50%) translateY(20px);
      }

      .control-button {
          background-color: rgba(40, 40, 40, 0.7);
          border: 1px solid #555;
          color: #e0e0e0;
          width: 48px;
          height: 48px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: all 0.2s ease-in-out;
      }
      .control-button:hover {
          background-color: rgba(60, 60, 60, 0.9);
          border-color: #777;
      }
      .control-button.active {
          background-color: #38a169;
          border-color: #68d391;
          color: white;
      }
      .control-button svg {
          width: 24px;
          height: 24px;
      }

      /* --- UI Overlays & Panels --- */
      .panel {
          position: fixed;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(18, 18, 18, 0.9);
          border-top: 1px solid #444;
          backdrop-filter: blur(8px);
          transition: transform 0.4s cubic-bezier(0.2, 1, 0.3, 1);
          z-index: 50;
          max-height: 85vh;
          transform: translateY(100%);
          display: flex;
          flex-direction: column;
      }
      .panel.active {
          transform: translateY(0);
      }
      .panel-header {
          padding: 1rem;
          text-align: center;
          border-bottom: 1px solid #444;
          flex-shrink: 0;
          position: relative;
      }
      .panel-content {
          padding: 1.5rem;
          overflow-y: auto;
      }
      
      /* --- Mobile-Optimized Controls --- */
      .themed-select, .themed-input {
          background-color: #2d3748;
          border: 1px solid #4a5568;
          border-radius: 0.375rem;
          padding: 0.75rem;
          color: #e0e0e0;
          font-family: 'Inter', sans-serif;
          font-size: 1rem;
      }
      .config-button-group { display: flex; flex-wrap: wrap; gap: 0.5rem; }
      .config-button {
          background-color: #2d3748; border: 1px solid #4a5568;
          padding: 0.5rem 1rem; border-radius: 0.375rem;
          transition: all 0.2s ease-in-out;
          cursor: pointer;
          flex-grow: 1;
          text-align: center;
          font-size: 0.875rem;
      }
      .config-button.active {
          background-color: #38a169; border-color: #68d391;
          color: white; font-weight: bold;
      }
      
      /* --- Tab buttons for settings panel --- */
      .tab-button-group {
          display: flex;
          gap: 0.5rem;
          border-bottom: 1px solid #444;
          padding: 0.5rem 1rem;
          background-color: rgba(10,10,10,0.5);
          flex-shrink: 0;
          overflow-x: auto;
      }
      .tab-button {
          background-color: transparent;
          border: 1px solid transparent;
          color: #a0aec0;
          padding: 0.5rem 0.75rem;
          border-radius: 0.375rem;
          transition: all 0.2s;
          white-space: nowrap;
      }
      .tab-button.active {
          background-color: #2d3748;
          border-color: #4a5568;
          color: white;
          font-weight: bold;
      }
      .tab-content {
          display: none;
      }
      .tab-content.active {
          display: block;
      }

      /* --- Grimoire styles --- */
      .reference-section dt {
          font-family: 'Special Elite', cursive;
          color: #fbbf77;
          font-weight: bold;
      }
      .reference-section dd {
          margin-left: 1rem;
          color: #a0aec0;
      }

      /* --- Toggle Switch for Edicts and Settings --- */
      .toggle-switch {
          position: relative;
          display: inline-block;
          width: 50px;
          height: 28px;
          flex-shrink: 0;
      }
      .toggle-switch input {
          opacity: 0;
          width: 0;
          height: 0;
      }
      .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #4a5568;
          transition: .4s;
          border-radius: 28px;
      }
      .slider:before {
          position: absolute;
          content: "";
          height: 20px;
          width: 20px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          transition: .4s;
          border-radius: 50%;
      }
      input:checked + .slider {
          background-color: #38a169;
      }
      input:disabled + .slider {
          background-color: #2d3748;
          cursor: not-allowed;
      }
      input:disabled + .slider:before {
          background-color: #718096;
      }
      input:checked + .slider:before {
          transform: translateX(22px);
      }

      /* --- Brush Toolbar Styles --- */
      #brush-toolbar {
          transition: opacity 0.3s, transform 0.3s;
      }
      #brush-toolbar.hidden {
          opacity: 0;
          transform: translate(-50%, -20px);
          pointer-events: none;
      }
      .toolbar-section {
          padding: 8px;
          border-radius: 6px;
          background-color: rgba(20,20,20,0.7);
      }
      .toolbar-button {
          background-color: #374151;
          border: 1px solid #4b5563;
          color: #d1d5db;
          padding: 4px 10px;
          border-radius: 4px;
          font-size: 0.8rem;
          transition: all 0.2s;
      }
      .toolbar-button.active {
          background-color: #38a169;
          border-color: #68d391;
          color: white;
          font-weight: 600;
      }
      .particle-swatch {
          width: 24px;
          height: 24px;
          border-radius: 50%;
          cursor: pointer;
          border: 2px solid transparent;
          transition: all 0.2s;
      }
      .particle-swatch.active {
          border-color: #fBBf77;
          transform: scale(1.1);
      }
    /* --- Anomaly Modal Styles --- */
      #anomaly-modal.hidden {
          opacity: 0;
          pointer-events: none;
      }
      #anomaly-modal:not(.hidden) #anomaly-modal-content {
          transform: scale(1);
      }
    /* --- Mobile-Specific Styles --- */
      @media (max-width: 768px) {
          /* Dock the main controls to the bottom */
          #main-controls {
              bottom: 0;
              left: 0;
              right: 0;
              width: 100%;
              transform: translateX(0);
              border-radius: 0;
              border-left: none;
              border-right: none;
              border-bottom: none;
              justify-content: space-around; /* Spread out buttons */
              padding: 8px 0;
          }
          #main-controls.hidden {
              transform: translateY(100%); /* Hide by sliding down */
          }

          /* Make control buttons slightly larger */
          .control-button {
              width: 52px;
              height: 52px;
          }
          .control-button svg {
              width: 28px;
              height: 28px;
          }

          /* Make panel tabs easier to tap */
          .tab-button {
              padding: 0.75rem 1rem;
              font-size: 1rem;
          }

          /* Make config buttons in settings easier to tap */
          .config-button {
              padding: 0.75rem 1rem;
              font-size: 1rem;
          }

          /* Increase toggle switch size for easier interaction */
          .toggle-switch {
              width: 60px;
              height: 34px;
          }
          .slider {
              border-radius: 34px;
          }
          .slider:before {
              height: 26px;
              width: 26px;
              left: 4px;
              bottom: 4px;
          }
          input:checked + .slider:before {
              transform: translateX(26px);
          }

          /* Ensure app content isn't hidden behind the new docked controls */
          #app-container {
              padding-bottom: 68px; /* Height of the docked bar + some padding */
          }
          /* Remove padding when controls are hidden to reclaim the space */
          #app-container.controls-hidden {
              padding-bottom: 0;
          }

          .title-header { font-size: 2.5rem; }
          .start-button { font-size: 1.25rem; }
      }

  </style>
</head>
<body>
    <div id="loading-overlay">
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>

    <div id="title-screen-overlay" class="hidden">
        <h1 class="title-header">Cellular SÃ©ance</h1>
        <button id="start-game-btn" class="start-button">Enter the SÃ©ance</button>
        <div class="about-section">
            <p>An interactive simulation of particle physics and emergent behaviors. Create your own universe by defining its laws, entities, and aesthetics. Observe how simple rules can lead to complex, unpredictable systems. Use the brush tool to paint new life or wield cosmic forces.</p>
        </div>
    </div>

    <div id="app-container">
        <div id="brush-toolbar" class="hidden fixed top-4 left-1/2 -translate-x-1/2 z-[150] bg-gray-900/80 backdrop-blur-md border border-gray-600 rounded-lg p-2 flex items-center gap-2 shadow-lg">
            <div class="toolbar-section flex items-center gap-2">
                <button class="toolbar-button" data-type="aetheric">Aetheric</button>
                <button class="toolbar-button" data-type="effect">Effect</button>
            </div>
            <div id="aetheric-brush-options" class="toolbar-section flex items-center gap-2 hidden">
                <span class="text-xs font-bold text-gray-300">Type:</span>
                <div id="particle-swatch-container" class="flex gap-1.5"></div>
            </div>
        </div>

        <div id="simulationContainer">
            <canvas id="simulationCanvas"></canvas>
            <div id="crt-overlay" class="hidden"></div>
        </div>
        
        <div id="main-controls">
            <button id="newGameButton" class="control-button" title="New SÃ©ance">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-4.991-2.695v-4.992m0 0h-4.992m4.992 0l-3.181-3.183a8.25 8.25 0 00-11.664 0l-3.181 3.183" /></svg>
            </button>
            <button id="replayButton" class="control-button" title="Replay SÃ©ance">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 16.023c1.885-1.885 1.885-4.94 0-6.825a4.803 4.803 0 00-6.825 0c-1.885 1.885-1.885 4.94 0 6.825a4.803 4.803 0 006.825 0zm-3.423-.707a3.375 3.375 0 01-4.773-4.773" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75v.007" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 17.25v.007" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 12h.007" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6.75 12h.007" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12a7.5 7.5 0 11-15 0 7.5 7.5 0 0115 0z" />
                </svg>
            </button>
            <button id="pauseButton" class="control-button" title="Pause">
                <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 5.25v13.5m-7.5-13.5v13.5" /></svg>
                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="hidden"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.25v13.5l13.5-6.75L5.25 5.25z" /></svg>
            </button>
            <button id="brush-shortcut-btn" class="control-button" title="Toggle Brush">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.53 16.122a3.75 3.75 0 01-5.654-5.654l3.536-3.536a3.75 3.75 0 015.654 5.654l-3.536 3.536z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 7.5l-1.875 1.875" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12.075 12.075L10.2 13.95m2.828-2.828l1.875-1.875M12 12l1.875 1.875" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.122 9.53a3.75 3.75 0 015.654 5.654l-3.536 3.536a3.75 3.75 0 01-5.654-5.654l3.536-3.536z" />
                </svg>
            </button>
            <button id="randomize-visage-shortcut-btn" class="control-button" title="Randomize Visage">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.5 21.75l-.398-1.188a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.188-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.188a2.25 2.25 0 001.423 1.423l1.188.398-1.188.398a2.25 2.25 0 00-1.423 1.423z" />
                </svg>
            </button>
            <button id="settings-btn" class="control-button" title="Settings">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-1.007 1.11-1.226.554-.22 1.197-.22 1.752 0 .549.22 1.02.684 1.11 1.226l.094.542c.063.372.333.696.701.83.354.128.734.195 1.116.195.42 0 .822-.072 1.183-.215.353-.135.724-.06.977.197.252.257.349.635.255 1.002l-.153.579c-.075.283-.075.585 0 .868l.153.579c.094.367.002.746-.255 1.002a1.125 1.125 0 01-1.226 1.11l-.542-.094c-.372-.063-.696-.333-.83-.701-.128-.354-.195-.734-.195-1.116 0-.42.072-.822.215-1.183.135-.353.06-.724-.197-.977-.257-.252-.635-.349-1.002-.255l-.579.153c-.283.075-.585.075-.868 0l-.579-.153c-.367-.094-.746-.002-1.002.255a1.125 1.125 0 01-1.11 1.226l-.542.094c-.372.063-.696.333-.83.701-.128-.354-.195.734-.195-1.116 0-.42-.072-.822-.215-1.183-.135-.353-.06-.724.197-.977.257-.252.635-.349 1.002-.255l.579-.153c.283-.075.585.075-.868 0l.579.153c.367.094.746.002 1.002-.255.252-.257.349.635.255-1.002l-.153-.579a1.125 1.125 0 01.255-1.002zM12 15.75a3.75 3.75 0 100-7.5 3.75 3.75 0 000 7.5z" /></svg>
            </button>
            </div>
    </div>

    <div id="settings-panel" class="panel">
        <button class="close-panel-btn absolute top-3 right-4 text-gray-500 hover:text-white transition-colors z-10">
            <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
        </button>
        <div id="settings-tabs" class="tab-button-group">
            <button class="tab-button active" data-tab="universe-tab">Universe</button>
            <button class="tab-button" data-tab="visage-tab">Visage</button>
            <button class="tab-button" data-tab="brush-tab">Brush</button>
            <button class="tab-button" data-tab="viewer-tab">Viewer</button>
            <button class="tab-button" data-tab="seed-tab">Seed</button>
            <button class="tab-button" data-tab="grimoire-tab">Grimoire</button>
            <button class="tab-button" data-tab="audio-tab">Audio</button>
        </div>
        <div class="panel-content">
            <div id="universe-tab" class="tab-content active space-y-6">
                <div id="gameSettingsPanel"></div>
                <div id="viewControls"></div>
            </div>
            <div id="visage-tab" class="tab-content space-y-6">
                <div id="cosmeticControls"></div>
            </div>
            <div id="brush-tab" class="tab-content space-y-6">
                </div>
            <div id="viewer-tab" class="tab-content space-y-6">
                <div id="viewerControls"></div>
            </div>
            <div id="seed-tab" class="tab-content space-y-6">
                <div id="seedControls"></div>
            </div>
            <div id="grimoire-tab" class="tab-content space-y-6">
                <div id="referenceContent"></div>
            </div>
            <div id="audio-tab" class="tab-content space-y-6">
                <div class="flex items-center justify-between">
                    <label for="audio-visualizer-toggle" class="font-bold special-elite text-xl cursor-pointer">Enable Microphone Visualizer</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="audio-visualizer-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div id="audio-options-container" class="hidden space-y-4">
                    <p class="text-sm text-gray-400">Select a visualization mode. The simulation will react to music and sound from your microphone.</p>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Visualization Mode</label>
                        <div id="audio-mode-group" class="config-button-group">
                            <button class="config-button active" data-mode="spectralFlux" title="Bass changes particle hue, mids change brightness, treble creates flashes.">Spectral Flux</button>
                            <button class="config-button" data-mode="rhythmicFlow" title="The bass level of the music drives the simulation's chaos and creates a subtle vortex.">Rhythmic Flow</button>
                            <button class="config-button" data-mode="cosmicPulse" title="Bass levels modulate the universe's background aether and charge.">Cosmic Pulse</button>
                            <button class="config-button" data-mode="synesthesia" title="A full-spectrum experience. Bass drives motion and shifts particle hues. Mids control brightness, and treble creates flashes.">Synesthesia</button>
                        </div>
                    </div>
                    <div>
                        <label for="audio-reactivity-slider" class="block mb-2 font-bold special-elite">Reactivity: <span id="audio-reactivity-label">1.0x</span></label>
                        <input type="range" id="audio-reactivity-slider" min="0.1" max="3.0" value="1.0" step="0.1" class="w-full">
                    </div>
                    <p id="audio-status" class="text-center text-yellow-400"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="anomaly-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-200 flex items-center justify-center p-4 transition-opacity duration-300 cursor-pointer">
        <div id="anomaly-modal-content" class="bg-gray-900 border-2 border-yellow-400 rounded-lg p-6 text-center shadow-2xl max-w-sm mx-auto transform transition-transform duration-300 scale-95">
            <h2 id="anomaly-modal-title" class="text-2xl font-bold special-elite text-yellow-300 mb-2">Anomaly Detected!</h2>
            <p id="anomaly-name" class="text-xl unifrakturmaguntia text-teal-300 mb-4"></p>
            <p id="anomaly-description" class="text-gray-300"></p>
        </div>
    </div>

    <script>
        //region --- DOM Elements ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const appContainer = document.getElementById('app-container');
        const simulationContainer = document.getElementById('simulationContainer');
        //endregion

        //region --- Main Controls ---
        const mainControls = document.getElementById('main-controls');
        const newGameButton = document.getElementById('newGameButton');
        const replayButton = document.getElementById('replayButton');
        const pauseButton = document.getElementById('pauseButton');
        const pauseIcon = document.getElementById('pause-icon');
        const playIcon = document.getElementById('play-icon');
        const settingsBtn = document.getElementById('settings-btn');
        const brushShortcutBtn = document.getElementById('brush-shortcut-btn');
        const randomizeVisageShortcutBtn = document.getElementById('randomize-visage-shortcut-btn');
        //endregion

        //region --- Panels ---
        const settingsPanel = document.getElementById('settings-panel');
        const settingsTabs = document.getElementById('settings-tabs');
        //endregion

        //region --- Panel Content Containers ---
        const gameSettingsPanel = document.getElementById('gameSettingsPanel');
        const cosmeticControls = document.getElementById('cosmeticControls');
        const viewerControls = document.getElementById('viewerControls');
        const viewControls = document.getElementById('viewControls');
        const seedControls = document.getElementById('seedControls');
        const referenceContent = document.getElementById('referenceContent');
        const brushTab = document.getElementById('brush-tab');
        const brushToolbar = document.getElementById('brush-toolbar');
        const anomalyModal = document.getElementById('anomaly-modal');
        //endregion

        // --- Simulation State ---
        let particles = [];
        let particleTypes = [];
        let interactionRules = {};
        let spaceRules = {};
        let cosmeticRules = {
            particleStyle: 'circle',                                                 
            particleEffect: 'none',
            backgroundStyle: 'solid',
            backgroundHue: Math.random() * 360,
            colorPalette: 'random_colors',
            parallaxHue: Math.random() * 360,
            viewerMode: 'none',
            containmentGeometry: 'vertical',
        };
        
        // --- User Preferences (Persisted) ---
        let fundamentalSettings = {
            allowMutate: false,
            allowDrain: false,
            longLifespan: false,
        };
        let inherentLawSettings = {
            predation: false,
            criticalMass: false,
            createGhosts: false,
            inertia: false,
            chainReaction: false,
            thermalShock: false,
        };
        let autoResetSettings = {
            threshold: 0 // 0 = disabled, 0.05 = 5%, 0.20 = 20%
        };
        
        //region --- Audio Visualizer State ---
        let audioContext;
        let analyser;
        let audioDataArray;
        let audioVisualizerState = {
            enabled: false,
            mode: 'spectralFlux',
            reactivity: 1.0, // NEW: Reactivity slider value
            lastBeatTime: 0,
            bass: 0,
            mids: 0,
            treble: 0,
            volume: 0,
            glowAmount: 0,
            bgFlash: 0,
        };
        //endregion
        
        // Settings for anomalies
        let anomalySettings = {
            frequency: 0.02 // Default to Rare (2%)
        };
        let backgroundSettings = {
            color: '#0a0a0a' // Default dark background
        };
        let brushSettings = {
            enabled: false,
            brushType: 'aetheric', // 'aetheric' or 'effect'
            aethericMode: 'stream', // 'stream', 'spray', 'pulse', 'calligrapher'
            effectMode: 'velocity', // 'velocity', 'typeMutator', 'shrapnel', 'eraser'
            selectedParticleTypeID: 0,
            size: 20,
            strength: 1,
        };
        let activeTemplateId = 'template-basic'; // Track the active template
        let initialConditions = {};
        let stars = [];
        let animationFrameId;
        let isPaused = false;
        let maxParticles = 500;
        let activeAnomaly = null;
        let worldWidth = 800;
        let worldHeight = 1200;
        
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
        
            /**
             * Calculates a unique string key for a cell based on coordinates.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             * @returns {string} The unique cell key.
             */
            _getKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            }
        
            /**
             * Adds a particle to its corresponding cell in the grid.
             * @param {object} particle - The particle to add.
             */
            addToCell(particle) {
                const key = this._getKey(particle.x, particle.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(particle);
            }
        
            /**
             * Retrieves all particles from the 3x3 grid of cells surrounding a given particle.
             * @param {object} particle - The particle to find neighbors for.
             * @returns {Array<object>} An array of all nearby particles.
             */
            getNearby(particle) {
                const nearbyParticles = [];
                const originX = Math.floor(particle.x / this.cellSize);
                const originY = Math.floor(particle.y / this.cellSize);
        
                // Iterate through the 3x3 grid of cells around the particle's cell
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const key = `${originX + i},${originY + j}`;
                        const cell = this.grid.get(key);
                        if (cell) {
                            // OPTIMIZED: Use a standard for loop instead of spread syntax for performance.
                            for (let k = 0, len = cell.length; k < len; k++) {
                               nearbyParticles.push(cell[k]);
                            }
                        }
                    }
                }
                return nearbyParticles;
            }
        
            /**
             * Clears the entire grid for the next frame.
             */
            clear() {
                this.grid.clear();
            }
            
            printLength() {
                console.log(this.grid.size);
            }
        }
        const spatialHash = new SpatialHash(150); // Cell size of 150 is a good starting point
        
        let nextParticleId = 0;

        //region --- Offscreen canvas for effects ---
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        //endregion

        //region --- Viewport State ---
        let viewTransform = new DOMMatrix();
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        let isInitialLoad = true;
        //endregion
        
        //region --- UI Interaction State ---
        let interactionStartX = 0;
        let interactionStartY = 0;
        let interactionMoved = false; 
        let isBrushing = false;
        let lastBrushX = 0;
        let lastBrushY = 0;
        //endregion
        
        // --- Constants ---
        const MAX_PARTICLE_SIZE = 75;
        const DEFAULT_SPACE_RULES = Object.freeze({
            vortex: 0, viscosity: 1.0, boundary: 'bounce', backgroundCharge: 0,
            gravityY: 0, brownianMotion: 0, elasticity: 0.8, spontaneousGeneration: 0,
            predation: false, criticalMass: Infinity, decayRate: 0.0001, createGhosts: false,
            inertia: false, chainReaction: false, thermalShock: false,
            ambientTemperature: 50, heatDissipation: 0.001, stateChangeFactor: 1.0,
            ambientAether: 50, aetherFlux: 0.001,
            resonantBondingThreshold: 0.1, resonantBondingStrength: 0.05,
            dissonanceThreshold: 0.85, enableResonanceBonding: false, enableDissonance: false,
        });
        const PARTICLE_STYLES = [
    'random', 'circle', 'hard', 'core', 'ringed', 'glitch', 'symbol', 'square', 
    'tiny_square', 'cross', 'triangle', 'ascii', 'i-ching', 'protostar', 
    'datamosh_block', 'scanline_error', 'ink_stroke', 'tiny_ink_stroke', 
    'astrological_symbol', 'rune'
];
        const PARTICLE_EFFECTS = ['none', 'glow', 'soft-glow', 'pulse-glow', 'translucent', 'scanlines', 'chromatic_aberration', 'mycelium', 'afterimage_trail', 'directional_cone', 'lenticular'];
        const BACKGROUND_STYLES = ['solid', 'gradient', 'grid', 'rings', 'parallax-grid', 'cold-war-board', 'crt_glow', 'interference_pattern'];
        const VIEWER_MODES = ['none', 'aether_density', 'doppler_shift'];
        const BEHAVIORS = [ 'attract', 'repel', 'mutate', 'merge', 'shatter', 'drain', 'ignore', 'charge_transfer', 'heat_transfer', 'aether_siphon' ];
        const SYMBOLS = ['â”€', 'â”‚', 'â•±', 'â•²', 'â•³', 'â—‹', 'â—‡', 'â–³', 'â–½', 'â¨', 'â¨‚', 'â¨Ž', 'â¨', 'â¨·', 'â¨¹', 'â©’', 'â©”', 'âª¢', 'âª¡'];
        const I_CHING_TRIGRAMS = ['â˜°', 'â˜±', 'â˜²', 'â˜³', 'â˜´', 'â˜µ', 'â˜¶', 'â˜·'];
        const RUNE_SYMBOLS = ['áš ', 'áš¢', 'áš¦', 'áš¨', 'áš±', 'áš²', 'áš·', 'áš¹', 'ášº', 'áš¾', 'á›', 'á›ƒ', 'á›‡', 'á›ˆ', 'á›‰', 'á›Š', 'á›', 'á›’', 'á›–', 'á›—', 'á›š', 'á›œ', 'á›Ÿ', 'á›ž'];
        const ASCII_CHARS = ['@', '#', '$', '%', '&', '*', '+', '=', '-', '.', ':', '^'];
        const ASTROLOGICAL_SYMBOLS = ['â˜‰', 'â˜½', 'â˜¿', 'â™€', 'â™‚', 'â™ƒ', 'â™„', 'â™…', 'â™†', 'â™‡', 'ðŸœ', 'ðŸœ‚', 'ðŸœƒ', 'ðŸœ„', 'ðŸœ', 'ðŸœš', 'ðŸœ”'];
        
        const COLOR_PALETTES = {
            // --- New Palettes ---
            'ukiyo_e_dreams': { name: 'Ukiyo-e Dreams', colors: ['#4B5D67', '#D95B3D', '#F3E5AB', '#73A580', '#E8ADAA', '#363031'] },
            'ectoplasm': { name: 'Ectoplasm', colors: ['#93E9BE', '#E0FFFF', '#3D555E', '#6A8EAE', '#F5FFFA', '#14283D'] },
            'stained_glass': { name: 'Stained Glass', colors: ['#780000', '#002F6C', '#006400', '#FFD700', '#B22222', '#4169E1'] },
            'art_deco_gala': { name: 'Art Deco Gala', colors: ['#0A0A0A', '#D4AF37', '#F5EFE0', '#009B77', '#0F52BA', '#C0C0C0'] },
            'apothecary_shelf': { name: 'Apothecary Shelf', colors: ['#5A5A35', '#C0A080', '#E8E4C9', '#874C30', '#3D555E', '#D1603D'] },
            'civil_twilight': { name: 'Civil Twilight', colors: ['#2A3064', '#B4869F', '#C8A2C8', '#E58752', '#40404F', '#181A2A'] },
            'opalescence': { name: 'Opalescence', colors: ['#F5F5F5', '#E6E6FA', '#93C572', '#89CFF0', '#F9D5E5', '#CACFD6'] },
            'celestial_silk': { name: 'Celestial Silk', colors: ['#D0C0E7', '#FAD9D5', '#B9E2D2', '#F0F8FF', '#A4A8D1', '#3A3F5E'] },
            'pop_dream': { name: 'Pop Dream', colors: ['#E2D2FF', '#FEC7D2', '#C4F0F7', '#FF00A0', '#FFFFFF', '#A9B3E3'] },
            'pastel_dream': { name: 'Pastel Dream', colors: ['#FFB7C5', '#C6A4FF', '#93E9BE', '#FFF7AD', '#F5F5F5', '#E54569'] },

            // --- Merged Palettes (FIXED) ---
            'infrared_spectrum': { name: 'Infrared Spectrum', hueRange: [-20, 40], satRange: [80, 100], lightRange: [50, 70] },
            'psychedelia': { name: 'Psychedelia', hueRange: [0, 360], satRange: [90, 100], lightRange: [60, 80] },
            
            // --- Existing Palettes ---
            'primary_secondary': { name: 'Primary & Secondary', colors: ['#FF0000', '#FFFF00', '#0000FF', '#FF7F00', '#008000', '#4B0082', '#008080', '#FF00FF', '#7FFF00', '#E6E6FA', '#FFC0CB', '#FFA500'] },
            'cool_analogous': { name: 'Cool Analogous', colors: ['#9ACD32', '#32CD32', '#008080', '#00FFFF', '#1E90FF', '#0000FF', '#483D8B', '#8A2BE2', '#9400D3', '#4B0082', '#6A5ACD', '#7B68EE'] },
            'warm_analogous': { name: 'Warm Analogous', colors: ['#ADFF2F', '#FFFF00', '#FFD700', '#FFA500', '#FF8C00', '#FF4500', '#FF0000', '#DC143C', '#C71585', '#FF1493', '#FF00FF', '#DB7093'] },
            'earthy_tones': { name: 'Earthy Tones', colors: ['#E2725B', '#6B8E23', '#D2B48C', '#708090', '#DAA520', '#800000', '#228B22', '#BC8F8F', '#556B2F', '#8B4513', '#2F4F4F', '#A0522D'] },
            'pastel_garden': { name: 'Pastel Garden', colors: ['#E6E6FA', '#98FB98', '#FFDAB9', '#ADD8E6', '#FAFAD2', '#FFB6C1', '#D8BFD8', '#B0E0E6', '#FFE4E1', '#F0FFF0', '#FFF0F5', '#F5FFFA'] },
            'jewel_tones': { name: 'Jewel Tones', colors: ['#00A86B', '#0047AB', '#B22222', '#8A2BE2', '#FFD700', '#FF7F50', '#008B8B', '#E34234', '#9932CC', '#FFBF00', '#4682B4', '#D2691E'] },
            'random_colors': { name: 'Random' },
            'true_random_colors': { name: 'True Random' },
            'risograph': { name: 'Risograph', colors: ['#FF007F', '#FFFF00', '#00FFFF'], special: 'multiply' },
            'rothko_chapel': { name: 'Rothko\'s Chapel', colors: ['#3D0C02', '#571F2C', '#241E4E', '#4B0082', '#1A092D', '#602B34'] },
            'gelato_shop': { name: 'Gelato Shop', colors: ['#93c572', '#ff7b9c', '#fff75e', '#ffb447', '#b1a2d6'] },
            'kuiper_anomaly': { name: 'Kuiper Anomaly (Analogous)', colors: ['#4B0082', '#483D8B', '#6A5ACD', '#7B68EE', '#000080', '#00008B', '#0000CD', '#1E90FF', '#87CEEB', '#ADD8E6', '#F0F8FF', '#191970'] },
            'triadic_supernova': { name: 'Supernova (Triadic)', colors: ['#FF00FF', '#FF1493', '#C71585', '#FFFF00', '#FFD700', '#F0E68C', '#00FFFF', '#40E0D0', '#20B2AA', '#FFFFFF', '#808080', '#000000'] },
            'quantum_entanglement': { name: 'Entanglement (Split-Comp)', colors: ['#ADFF2F', '#7FFF00', '#32CD32', '#9ACD32', '#8A2BE2', '#9400D3', '#9932CC', '#4B0082', '#FF4500', '#FF6347', '#E65100', '#FFFFFF'] },
            'celestial_masquerade': { name: 'Masquerade (Tetradic)', colors: ['#FF4500', '#FF7F50', '#008B8B', '#20B2AA', '#483D8B', '#6A5ACD', '#FFD700', '#F0E68C', '#E65100', '#006778', '#3A2E7A', '#FFC400'] },
            'alchemical_mishap': { name: 'Alchemical Mishap', colors: ['#50c878', '#9966cc', '#ff7518', '#c0c0c0', '#4b0082', '#3cb371', '#ba55d3', '#ff8c00', '#d3d3d3', '#8a2be2', '#20b2aa', '#ffd700'] },
            'americana': { name: 'Americana', colors: ['#b22222', '#8b0000', '#f5f5dc', '#fff8dc', '#6495ed', '#4682b4', '#314152', '#daa520', '#cd853f', '#8b4513', '#a9a9a9', '#708090'] },
            'arcade_floor': { name: 'Arcade Floor', colors: ['#ff00ff', '#00ffff', '#39ff14', '#f7b538', '#7209b7', '#f94144', '#f3722c', '#90be6d', '#43aa8b', '#577590', '#F9C74F', '#00CFE8'] },
            'aura': { name: 'Aura', colors: ['#D72638', '#3F3FBF', '#2D8C35', '#F4A261', '#6A3E78', '#E55C6C', '#6B6BE2', '#58A360', '#F6B780', '#8D689C', '#C41E3A', '#1C1C9A'] },
            'badlands': { name: 'Badlands', hueRange: [20, 50], satRange: [40, 70], lightRange: [30, 60] },
            'bit_rot': { name: 'Bit Rot', colors: ['#808095', '#EBDD50', '#6B5A49', '#FFFFFF', '#010101', '#A3A3B4', '#F0E68C', '#8D7B68', '#E0E0E0', '#1A1A1A', '#606075', '#D4C941']},
            'bone_china': { name: 'Bone China', colors: ['#f9f6ee', '#e0e6e9', '#cad3d9', '#a52a2a', '#f5f5f5', '#e9e3d9', '#cdd4d7', '#b3bec6', '#8b4513', '#d3d3d3', '#fffaf0', '#800000'] },
            'carnival_after_midnight': { name: 'Carnival After Midnight', colors: ['#7a3b3b', '#b58b00', '#1a3a5a', '#6b4a7b', '#c2b280', '#222222', '#5a2d2d', '#8c6d00', '#0d2b45', '#4d325a', '#f5deb3', '#800000'] },
            'celestial_chart': { name: 'Celestial Chart', colors: ['#F5DEB3', '#DEB887', '#D2B48C', '#BC8F8F', '#000080', '#483D8B', '#6A5ACD', '#FFD700', '#DAA520', '#B8860B', '#FFFFFF', '#2F4F4F'] },
            'celestial_realm': { name: 'Celestial Realm', colors: ['#010c21', '#0b193a', '#f0f8ff', '#e6e6fa', '#fffacd', '#ffd700', '#c0c0c0', '#add8e6', '#dda0dd', '#ffb6c1', '#f5b8d5', '#bfa6e0'] },
            'charli_xcx_brat': { name: 'Brat', colors: ['#8ace00', '#000000', '#FFFFFF', '#222222', '#444444', '#666666', '#888888', '#aaaaaa', '#cccccc', '#eeeeee', '#99dd11', '#77bb00'] },
            'cherenkov_radiation': { name: 'Cherenkov Radiation', colors: ['#001021', '#003366', '#0077ff', '#66ccff', '#e0ffff'] },
            'chromatic_split': { name: 'Chromatic Split', colors: ['#00FFFF', '#FF00FF', '#FFFF00', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FF7F00', '#7F00FF', '#FF4500', '#1E90FF', '#ADFF2F'] },
            'clouds_and_dreams': { name: 'Clouds & Dreams', hueRange: [180, 280], satRange: [20, 50], lightRange: [70, 95] },
            'cold_war_tech': { name: 'Cold War Tech', colors: ['#4CAF50', '#388E3C', '#000000', '#FFFFFF', '#FF5722', '#607D8B', '#81C784', '#5FA463', '#333333', '#CCCCCC', '#FF8A65', '#90A4AE'] },
            'cosmic_horror': { name: 'Cosmic Horror', colors: ['#536e53', '#b15f78', '#6a0dad', '#0e0513', '#c9ae7a', '#3b523b', '#8e445f', '#4c007d', '#2f2f4f', '#a68a56', '#293d29', '#d18a9d'] },
            'crystal_caves': { name: 'Crystal Caves', hueRange: [170, 300], satRange: [60, 90], lightRange: [60, 90] },
            'deep_sea_camouflage': { name: 'Deep Sea Camo', colors: ['#6b633f', '#d48795', '#7b4b94', '#e7e2d9', '#4b83a3', '#8f865f', '#e0a3ad', '#9c73b3', '#ffffff', '#73a5c1', '#524a2f', '#c96f7e'] },
            'deep_sea_vents': { name: 'Deep Sea Vents', colors: ['#02040f', '#0a0c24', '#13184a', '#2d3a8a', '#f0f8ff', '#ffffa0', '#ffd700', '#ffa500', '#ff4500', '#cd5c5c', '#8b4513', '#4a2a0a'] },
            'deep_space_radio': { name: 'Deep Space Radio', hueRange: [200, 280], satRange: [50, 80], lightRange: [10, 40] },
            'eldritch_glow': { name: 'Eldritch Glow', colors: ['#2e0249', '#570a57', '#a91079', '#f806cc', '#490B3D', '#7A1F5A', '#C73B9E', '#E980D2', '#14001F', '#7E007E', '#FF44CC', '#9A0061'] },
            'evergreen': { name: 'Evergreen', colors: ['#042804', '#1a2a1a', '#2e8b57', '#556b2f', '#6b8e23', '#8fbc8f', '#9ccc65', '#a9a9a9', '#d2b48c', '#665d1e', '#4a412a', '#f5f5dc']},
            'fallout_shelter': { name: 'Fallout Shelter', colors: ['#2E7D32', '#4CAF50', '#FFEB3B', '#FFC107', '#212121', '#BDBDBD', '#0091EA', '#66BB6A', '#FFF176', '#FFD54F', '#424242', '#757575'] },
            'fever_dream': { name: 'Fever Dream', colors: ['#ff0054', '#ff5400', '#ffbd00', '#00f5d4', '#00bbf9', '#f94144', '#f3722c', '#f8961e', '#43aa8b', '#277da1', '#E71D36', '#9B5DE5'] },
            'forest': { name: 'Forest', hueRange: [80, 150], satRange: [40, 70], lightRange: [20, 50] },
            'glowing_sea': { name: 'Glowing Sea', colors: ['#020428', '#00ced1', '#20b2aa', '#48d1cc', '#00fa9a', '#7fffd4', '#40e0d0', '#afeeee', '#00ffff', '#98fb98', '#f0fff0', '#e0ffff']},
            'halloween_night': { name: 'Halloween Night', colors: ['#000000', '#1a1a1a', '#ff6600', '#ff9900', '#ffcc00', '#4b0082', '#6a0dad', '#8a2be2', '#f5f5f5', '#a9a9a9', '#32cd32', '#9acd32'] },
            'hilma_af_klint': { name: 'Hilma af Klint', colors: ['#f9d5e5', '#fff2cc', '#c8e7f5', '#f6e05e', '#ff6b6b', '#663399', '#4a4a4a', '#ffffff', '#f0a83c', '#5bcefa', '#a3e0c3', '#000000'] },
            'hologram': { name: 'Hologram', colors: ['#00FFFF', '#FF00FF', '#FFFF00', '#FFFFFF', '#7DF9FF', '#F47FFF', '#C1FF7D', '#FFD700', '#B0E0E6', '#FFB6C1', '#98FB98', '#E6E6FA'] },
            'hypnagogia': { name: 'Hypnagogia', hueRange: [240, 340], satRange: [30, 60], lightRange: [40, 70] },
            'iconographers_tones': { name: 'Iconographer\'s Tones', colors: ['#0047AB', '#DC143C', '#FFD700', '#FFFFFF', '#2F4F4F', '#4169E1', '#E34234', '#F0E68C', '#F5F5F5', '#00008B', '#B22222', '#DAA520']},
            'inferno': { name: 'Inferno', hueRange: [-10, 60], satRange: [90, 100], lightRange: [40, 70] },
            'jesters_funeral': { name: 'Jester\'s Funeral', colors: ['#FF00FF', '#00FFFF', '#FFFF00', '#00FF00', '#000000', '#800080', '#008080', '#808000', '#008000', '#FFFFFF', '#ff3399', '#33ccff'] },
            'liquid_light_show': { name: 'Liquid Light', colors: ['#14003c', '#420052', '#780064', '#ff0078', '#ff425a', '#ff843c', '#ffc61a', '#ffff00', '#00ff78', '#00c6ff', '#0084ff', '#0042ff'] },
            'liquid_nightshade': { name: 'Liquid Nightshade', colors: ['#480048', '#003300', '#6a0dad', '#8F00FF', '#006400', '#50c878', '#3b003b', '#004d00', '#800080', '#2e8b57', '#9370DB', '#008080'] },
            'monet_sunrise': { name: 'Monet: Sunrise', colors: ['#758896', '#93a3b1', '#b3c1c8', '#4a545c', '#ff4500', '#ff6347', '#ff7f50', '#f2a689', '#1e2b35', '#34495e', '#fde49c', '#f8c76c'] },
            'monochrome': { name: 'Monochrome' },
            'nebula_remnant': { name: 'Nebula Remnant', hueRange: [250, 330], satRange: [60, 90], lightRange: [30, 70] },
            'neon_nightfall': { name: 'Neon Nightfall', colors: ['#0d0221', '#261447', '#3a1c71', '#ff00ff', '#00ffff', '#f72585', '#7209b7', '#3a0ca3', '#4361ee', '#4cc9f0', '#ffffff', '#f0f0f0'] },
            'no_clip_error': { name: 'No-Clip Error', colors: ['#FF00FF', '#000000', '#FFFFFF', '#808080', '#C0C0C0', '#00FF00', '#0000FF', '#FF0000', '#FFFF00', '#00FFFF', '#333333', '#666666'] },
            'oceanic': { name: 'Oceanic', hueRange: [180, 240], satRange: [50, 100], lightRange: [20, 70] },
            'overgrowth': { name: 'Overgrowth', colors: ['#556b2f', '#6b8e23', '#2e8b57', '#8b4513', '#a0522d', '#cd853f', '#808080', '#a9a9a9', '#ff00ff', '#da70d6', '#db7093', '#ffffff'] },
            'polarized_light': { name: 'Polarized Light', hueRange: [0, 360], satRange: [100, 100], lightRange: [50, 50] },
            'pride_flag_progress': { name: 'Pride (Progress)', colors: ['#E40303', '#FF8C00', '#FFED00', '#008026', '#24408E', '#732982', '#FFFFFF', '#FFAFC8', '#5BCEFA', '#61380B', '#000000', '#FFD800'] },
            'rca_signal': { name: 'RCA Signal', colors: ['#BE3C23', '#6886A2', '#E8C13A', '#63A77C', '#8A8A8A', '#D9654F', '#8FABC4', '#EDD16B', '#8BC8A0', '#A8A8A8', '#A22A12', '#4D6B83'] },
            'rorschach_inkblot': { name: 'Rorschach', colors: ['#000000', '#111111', '#222222', '#FFFFFF', '#F5F5F5', '#EAEAEA', '#DCDCDC', '#A9A9A9', '#808080', '#505050', '#707070', '#333333'] },
            'seasonal_cycle': { name: 'Seasonal Cycle', colors: ['#e0f2f1', '#a5d6a7', '#ffca28', '#d84315', '#6a1b9a'] },
            'sentient_oil_slick': { name: 'Oil Slick', hueRange: [0, 360], satRange: [50, 80], lightRange: [20, 50] },
            'soviet_constructivism': { name: 'Soviet Constructivism', colors: ['#E22D25', '#F5D600', '#000000', '#FFFFFF', '#A9B4B8', '#ED5F59', '#F8E24C', '#2A2A2A', '#DCDCDC', '#8A9498', '#B31A13', '#CBB800'] },
            'strobing_complements': { name: 'Strobing', colors: ['#FF0000', '#00FFFF', '#0000FF', '#FFFF00', '#FF00FF', '#00FF00', '#FF8000', '#007FFF', '#8000FF', '#7FFF00', '#FFFFFF', '#000000'] },
            'suburban_twilight': { name: 'Suburban Twilight', colors: ['#04203a', '#ff8c00', '#dcdcdc', '#2d2d2d', '#5a6d7c', '#021323', '#cc6e00', '#ababab', '#444444', '#3e4a55', '#f5f5f5', '#ffaa33'] },
            'sunken_treasure': { name: 'Sunken Treasure', colors: ['#003f5c', '#444e86', '#955196', '#dd5182', '#ff6e54', '#ffa600', '#006778', '#008b8b', '#f9a11b', '#3b5998', '#ffcb2d', '#b03a2e'] },
            'sunrise': { name: 'Sunrise', hueRange: [0, 60], satRange: [70, 100], lightRange: [50, 80] },
            'sunset': { name: 'Sunset', colors: ['#2d2d44', '#433d59', '#6c5984', '#a17aa8', '#d39bbc', '#ffb5b5', '#ffc8a8', '#ffde99', '#ffe98a', '#3a1c71', '#d76d77', '#ffac81']},
            'synthwave': { name: 'Synthwave', hueRange: [260, 340], satRange: [80, 100], lightRange: [50, 70] },
            'synthwave_sunset': { name: 'Synthwave Sunset', colors: ['#ffbe0b', '#fb5607', '#ff006e', '#8338ec', '#3a86ff', '#f72585', '#7209b7', '#480ca8', '#4cc9f0', '#f9c74f', '#fca311', '#e71d36'] },
            'the_golden_flower': { name: 'Golden Flower', colors: ['#ffd700', '#ffc400', '#ffb300', '#ff4500', '#c70000', '#00a86b', '#2e8b57', '#0047ab', '#002366', '#f5f5dc', '#222222', '#ffffff'] },
            'the_underworld': { name: 'The Underworld', colors: ['#000000', '#1a0000', '#330000', '#ff4500', '#ff6347', '#dc143c', '#483d8b', '#00ced1', '#20b2aa', '#98fb98', '#f0e68c', '#555555'] },
            'vantablack_singularity': { name: 'Singularity', colors: ['#000000', '#010101', '#020202', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#00FFFF', '#FFFF00', '#FF8C00', '#732982'] },
            'vga_corruption': { name: 'VGA Corruption', colors: ['#FF00FF', '#00FFFF', '#00FF00', '#FF0000', '#0000AA', '#000000', '#FF55FF', '#55FFFF', '#55FF55', '#FF5555', '#5555FF', '#555555']},
            'viridis': { name: 'Viridis', colors: ['#440154', '#3b528b', '#21908d', '#5dc863', '#fde725'] },
            'wave_function': { name: 'Wave Function', colors: ['#a7c5eb', '#c8e6c9', '#cfd8dc', '#ffffff', '#82b1ff', '#a5d6a7', '#b0bec5', '#f5f5f5', '#64b5f6', '#dcedc8', '#e0e0e0', '#e3f2fd']},
            'wicked': { name: 'Wicked', colors: ['#00D100', '#00A300', '#007500', '#F4A4C8', '#FFDDF4', '#FF69B4', '#D4AF37', '#B8860B', '#4A2A0A', '#3A2A5B', '#1A1A1A', '#FFFFFF'] },
            'witching_hour': { name: 'Witching Hour', hueRange: [250, 310], satRange: [20, 50], lightRange: [10, 40] },
            'witchs_cauldron': { name: 'Witch\'s Cauldron', colors: ['#121212', '#222222', '#333333', '#32cd32', '#7cfc00', '#adff2f', '#9400d3', '#9932cc', '#ba55d3', '#ff00ff', '#ff1493', '#c71585'] },
            'wizard_of_oz': { name: 'Wizard of Oz', colors: ['#89CFF0', '#B0E0E6', '#FFD700', '#FFED00', '#9B111E', '#009E60', '#4682B4', '#FFFFFF', '#000000', '#C0C0C0', '#50C878', '#FFF8DC'] },
            'zoning_authority': { name: 'Zoning Authority', colors: ['#a3b18a', '#fca311', '#e63946', '#457b9d', '#8d99ae'] },
        };

        //region Definitions/Descriptions
        // NEW: Template definitions
        const templates = {
            'template-basic': {
                name: 'Basic',
                description: 'The default starting point. A clean slate.',
                settings: {
                    backgroundColor: '#0a0a0a',
                    backgroundStyle: 'solid',
                    particleStyle: 'circle',
                    particleEffect: 'none',
                    colorPalette: 'random_colors'
                }
            },
            'template-cosmic-web': {
                name: 'Cosmic Web',
                description: 'A vast, interconnected network of tiny entities drifting through the void, reminiscent of galactic filaments or a neural map.',
                settings: {
                    backgroundColor: '#0a0a0a',
                    backgroundStyle: 'solid',
                    particleStyle: 'tiny_square',
                    particleEffect: 'mycelium',
                    colorPalette: 'true_random_colors'
                }
            },
            'template-crt': {
                name: 'CRT Interface',
                description: 'This template emulates the look of a classic monochrome CRT monitor, perfect for a retro-hacker or terminal aesthetic.',
                settings: {
                    backgroundColor: '#0a0a0a',
                    backgroundStyle: 'crt_glow',
                    particleStyle: 'ascii',
                    particleEffect: 'glow',
                    colorPalette: 'cold_war_tech'
                }
            },
            'template-the-abyss': {
                name: 'The Abyss',
                description: 'Descend into the crushing, inky blackness of the deep ocean, where the only light comes from strange, bioluminescent creatures.',
                settings: {
                    backgroundColor: '#020428', // Deep ocean
                    backgroundStyle: 'solid',
                    particleStyle: 'circle',
                    particleEffect: 'afterimage_trail',
                    colorPalette: 'cherenkov_radiation'
                }
            },
            'template-vga': {
                name: 'VGA Corruption',
                description: 'A chaotic and glitchy aesthetic that looks like a corrupted piece of old computer hardware struggling to render an image.',
                settings: {
                    backgroundColor: '#282c34',
                    backgroundStyle: 'interference_pattern',
                    particleStyle: 'glitch',
                    particleEffect: 'chromatic_aberration',
                    colorPalette: 'vga_corruption'
                }
            },
            'template-glowing-dream': {
                name: 'Glowing Dream',
                description: 'Vibrant, pulsing entities in a sea of darkness, fueled by a high-energy beat.',
                settings: {
                    backgroundColor: '#0a0a0a',
                    backgroundStyle: 'solid',
                    particleStyle: 'hard',
                    particleEffect: 'pulse-glow',
                    colorPalette: 'fever_dream'
                }
            },
        };
        const ALL_ANOMALIES = [
            { id: 'vortex', name: "Whirlpool", category: 'Space', apply: () => spaceRules.vortex = 0.04, unapply: () => spaceRules.vortex = DEFAULT_SPACE_RULES.vortex },
            { id: 'viscosity', name: "Thick Aether", category: 'Space', apply: () => spaceRules.viscosity = 0.96, unapply: () => spaceRules.viscosity = DEFAULT_SPACE_RULES.viscosity },
            { id: 'wrap_walls', name: "Illusory Walls", category: 'Space', apply: () => spaceRules.boundary = 'wrap', unapply: () => spaceRules.boundary = DEFAULT_SPACE_RULES.boundary },
            { id: 'charged_atm', name: "Charged Atmosphere", category: 'Space', apply: () => spaceRules.backgroundCharge = 0.2, unapply: () => spaceRules.backgroundCharge = DEFAULT_SPACE_RULES.backgroundCharge },
            { id: 'gravity', name: "Universal Gravity", category: 'Space', apply: () => spaceRules.gravityY = 0.1, unapply: () => spaceRules.gravityY = DEFAULT_SPACE_RULES.gravityY },
            { id: 'brownian', name: "Chaotic Energy", category: 'Space', apply: () => spaceRules.brownianMotion = 0.25, unapply: () => spaceRules.brownianMotion = DEFAULT_SPACE_RULES.brownianMotion },
            { id: 'predation', name: "Predation", category: 'Particle', apply: () => spaceRules.predation = true, unapply: () => spaceRules.predation = DEFAULT_SPACE_RULES.predation },
            { id: 'critical_mass', name: "Critical Mass", category: 'Particle', apply: () => spaceRules.criticalMass = 20, unapply: () => spaceRules.criticalMass = DEFAULT_SPACE_RULES.criticalMass },
            { id: 'conservation', name: "Conservation", category: 'Particle', apply: () => spaceRules.decayRate = 0, unapply: () => spaceRules.decayRate = DEFAULT_SPACE_RULES.decayRate },
            { id: 'ghosts', name: "Void Echoes", category: 'Particle', apply: () => spaceRules.createGhosts = true, unapply: () => spaceRules.createGhosts = DEFAULT_SPACE_RULES.createGhosts },
            { id: 'inelastic', name: "Imperfect Collisions", category: 'Particle', apply: () => spaceRules.elasticity = 0.4, unapply: () => spaceRules.elasticity = DEFAULT_SPACE_RULES.elasticity },
            { id: 'spontaneous_gen', name: "Spontaneous Apparition", category: 'Particle', apply: () => spaceRules.spontaneousGeneration = 0.001, unapply: () => spaceRules.spontaneousGeneration = DEFAULT_SPACE_RULES.spontaneousGeneration },
            { id: 'inertia', name: "Inertia", category: 'Particle', apply: () => spaceRules.inertia = true, unapply: () => spaceRules.inertia = DEFAULT_SPACE_RULES.inertia },
            { id: 'chain_reaction', name: "Cascading Destruction", category: 'Particle', apply: () => spaceRules.chainReaction = true, unapply: () => spaceRules.chainReaction = DEFAULT_SPACE_RULES.chainReaction },
            { id: 'thermal_shock', name: "Thermal Shock", category: 'Thermodynamics', apply: () => spaceRules.thermalShock = true, unapply: () => spaceRules.thermalShock = DEFAULT_SPACE_RULES.thermalShock },
            { id: 'absolute_zero', name: "Absolute Zero", category: 'Thermodynamics', mutuallyExclusive: 'temp_mod', apply: () => spaceRules.ambientTemperature = -50, unapply: () => spaceRules.ambientTemperature = DEFAULT_SPACE_RULES.ambientTemperature },
            { id: 'supernova', name: "Supernova", category: 'Thermodynamics', mutuallyExclusive: 'temp_mod', apply: () => spaceRules.ambientTemperature = 200, unapply: () => spaceRules.ambientTemperature = DEFAULT_SPACE_RULES.ambientTemperature },
            { id: 'phase_volatility', name: "Phase Volatility", category: 'Thermodynamics', apply: () => spaceRules.stateChangeFactor = 0.5, unapply: () => spaceRules.stateChangeFactor = DEFAULT_SPACE_RULES.stateChangeFactor },
            { id: 'aetheric_tide', name: "Aetheric Tide", category: 'Aether & Resonance', mutuallyExclusive: 'aether_mod', apply: () => spaceRules.ambientAether = 100, unapply: () => spaceRules.ambientAether = DEFAULT_SPACE_RULES.ambientAether },
            { id: 'entropic_field', name: "Entropic Field", category: 'Aether & Resonance', mutuallyExclusive: 'aether_mod', apply: () => { spaceRules.ambientAether = 0; spaceRules.aetherFlux = 0.005; }, unapply: () => { spaceRules.ambientAether = DEFAULT_SPACE_RULES.ambientAether; spaceRules.aetherFlux = DEFAULT_SPACE_RULES.aetherFlux; } },
            { id: 'resonant_harmony', name: "Resonant Harmony", category: 'Aether & Resonance', apply: () => spaceRules.enableResonanceBonding = true, unapply: () => spaceRules.enableResonanceBonding = DEFAULT_SPACE_RULES.enableResonanceBonding },
            { id: 'dissonant_feedback', name: "Dissonant Feedback", category: 'Aether & Resonance', apply: () => spaceRules.enableDissonance = true, unapply: () => spaceRules.enableDissonance = DEFAULT_SPACE_RULES.enableDissonance },
        ];
        const ANOMALY_DESCRIPTIONS = {
            vortex: "Creates a spiral vortex at the center of the universe.",
            viscosity: "Increases the 'thickness' of space, slowing down all particles.",
            wrap_walls: "Particles leaving one edge of the universe reappear on the opposite side.",
            charged_atm: "The background of space exerts a force on charged particles.",
            gravity: "A constant downward pull affects all particles.",
            brownian: "Introduces random, jittery motion to all particles.",
            predation: "Allows larger particles to consume smaller ones on contact.",
            critical_mass: "Causes particles that grow too large to violently shatter.",
            conservation: "Prevents particles from decaying due to age.",
            ghosts: "Causes dying particles to leave behind a temporary, ethereal echo.",
            inelastic: "Makes collisions less 'bouncy', causing particles to lose energy.",
            spontaneous_gen: "Allows new particles to spontaneously appear from the void.",
            inertia: "Heavier particles become more resistant to changes in motion.",
            chain_reaction: "Allows shattering particles to trigger explosions in nearby unstable particles.",
            thermal_shock: "Rapid temperature changes can cause particles to shatter.",
            absolute_zero: "Drastically reduces the ambient temperature of the universe.",
            supernova: "Drastically increases the ambient temperature of the universe.",
            phase_volatility: "Makes particles change between solid, liquid, and gas states more easily.",
            aetheric_tide: "Greatly increases the ambient level of aether in the universe.",
            entropic_field: "Causes all particles and the universe itself to slowly lose aether.",
            resonant_harmony: "Creates a strong attractive bond between particles with similar frequencies.",
            dissonant_feedback: "Causes particles with clashing frequencies to shatter on contact.",
            // Descriptions for Special Anomalies
            strange_attractor: 'A singularity of immense gravity has formed. All things are drawn to it.',
            strange_repulsor: 'A font of anti-gravity pushes all things away with unstoppable force.',
            odd_particle: 'A bizarre, contagious stillness has entered the universe. Do not touch.'
        };
        //endregion
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }
        
        //region showAnomlyModal()
        /**
         * Displays a modal to announce a detected anomaly.
         * @param {object} anomaly - The active anomaly object.
        */
        function showAnomalyModal(anomaly) {
    if (!anomaly) return;

    const modal = document.getElementById('anomaly-modal');
    const titleEl = document.getElementById('anomaly-modal-title');
    const nameEl = document.getElementById('anomaly-name');
    const descEl = document.getElementById('anomaly-description');

    titleEl.textContent = anomaly.isSpecial ? "Special Anomaly Detected!" : "Anomaly Detected!";
    nameEl.textContent = anomaly.name;
    descEl.textContent = ANOMALY_DESCRIPTIONS[anomaly.id];

    modal.classList.remove('hidden');

    // Automatically hide the modal after a few seconds
    setTimeout(() => {
        modal.classList.add('hidden');
    }, 5000); // Keep it on screen for 5 seconds
}
        //endregion()

        //region --- Audio Visualizer Core Functions ---
        async function initAudioVisualizer() {
            const statusEl = document.getElementById('audio-status');
            if (audioContext) return; // Already initialized

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusEl.textContent = 'Error: Your browser does not support microphone access.';
                return;
            }
            try {
                statusEl.textContent = 'Requesting microphone access...';
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.75; // Adjusted smoothing for better response

                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                audioDataArray = new Uint8Array(analyser.frequencyBinCount);
                audioVisualizerState.enabled = true;
                statusEl.textContent = 'Microphone connected! ðŸŽ¤';
                console.log("Audio visualizer enabled.");

            } catch (err) {
                statusEl.textContent = `Error enabling microphone: ${err.message}`;
                console.error('Error enabling microphone visualizer:', err);
                // Ensure UI is correctly disabled on error
                audioVisualizerState.enabled = false;
                document.getElementById('audio-visualizer-toggle').checked = false;
                document.getElementById('audio-options-container').classList.add('hidden');
            }
        }

        function stopAudioVisualizer() {
            if (audioContext) {
                audioContext.close().then(() => {
                    audioContext = null;
                    analyser = null;
                });
            }
            audioVisualizerState.enabled = false;
            // Reset any lingering audio-driven effects
            spaceRules.gravityY = DEFAULT_SPACE_RULES.gravityY;
            spaceRules.brownianMotion = DEFAULT_SPACE_RULES.brownianMotion;
            spaceRules.vortex = DEFAULT_SPACE_RULES.vortex;
            spaceRules.viscosity = DEFAULT_SPACE_RULES.viscosity;
            spaceRules.backgroundCharge = DEFAULT_SPACE_RULES.backgroundCharge;
            spaceRules.ambientAether = DEFAULT_SPACE_RULES.ambientAether;
            const statusEl = document.getElementById('audio-status');
            if (statusEl) statusEl.textContent = 'Microphone disabled.';
            console.log("Audio visualizer disabled.");
        }

        function updateAudioVisuals() {
            if (!audioVisualizerState.enabled || !analyser) return;

            analyser.getByteFrequencyData(audioDataArray);
            const bufferLength = analyser.frequencyBinCount;

            // --- Feature Extraction ---
            const bassEnd = Math.floor(bufferLength * 0.15);
            const midsEnd = Math.floor(bufferLength * 0.5);
            const trebleStart = Math.floor(bufferLength * 0.5);

            let bassSum = 0, midsSum = 0, trebleSum = 0, volumeSum = 0;
            for (let i = 0; i < bassEnd; i++) bassSum += audioDataArray[i];
            for (let i = bassEnd; i < midsEnd; i++) midsSum += audioDataArray[i];
            for (let i = trebleStart; i < bufferLength; i++) trebleSum += audioDataArray[i];
            for (let i = 0; i < bufferLength; i++) volumeSum += audioDataArray[i];

            const bassLevel = (bassSum / (bassEnd || 1)) / 255;
            const midsLevel = (midsSum / ((midsEnd - bassEnd) || 1)) / 255;
            const trebleLevel = (trebleSum / ((bufferLength - trebleStart) || 1)) / 255;
            const volumeLevel = (volumeSum / (bufferLength || 1)) / 255;

            // --- Increased lerp values for much faster response ---
            audioVisualizerState.bass = lerp(audioVisualizerState.bass, bassLevel, 0.9);
            audioVisualizerState.mids = lerp(audioVisualizerState.mids, midsLevel, 0.9);
            audioVisualizerState.treble = lerp(audioVisualizerState.treble, trebleLevel, 0.9);
            audioVisualizerState.volume = lerp(audioVisualizerState.volume, volumeLevel, 0.9);
            
            // Fade out one-shot effects
            if (audioVisualizerState.bgFlash > 0) audioVisualizerState.bgFlash -= 0.05;
            
            const reactivity = audioVisualizerState.reactivity;

            // --- Apply Visuals Based on Mode ---
            switch (audioVisualizerState.mode) {
                case 'spectralFlux':
                    particles.forEach(p => {
                        const hueShift = (audioVisualizerState.bass - 0.2) * 360 * reactivity;
                        const newHue = (p.type.hue + hueShift + 360) % 360;

                        let newLightness = 40 + (audioVisualizerState.mids * 50 * reactivity);

                        const flashAmount = Math.max(0, (audioVisualizerState.treble - 0.5)) * reactivity;
                        if (flashAmount > 0.05) {
                           newLightness = Math.min(100, newLightness + (100 - newLightness) * flashAmount * 2);
                        }
                        p.color = `hsl(${newHue}, 90%, ${newLightness}%)`;
                    });
                    break;
                
                case 'rhythmicFlow':
                    spaceRules.brownianMotion = audioVisualizerState.bass * 60.0 * reactivity; 
                    spaceRules.vortex = audioVisualizerState.bass * 3.0 * reactivity; 
                    break;

                case 'cosmicPulse':
                    spaceRules.backgroundCharge = (audioVisualizerState.bass - 0.1) * 0.5 * reactivity;
                    spaceRules.ambientAether = DEFAULT_SPACE_RULES.ambientAether + (audioVisualizerState.bass * 50 * reactivity);
                    break;

                case 'synesthesia':
                    // --- Motion from Rhythmic Flow ---
                    spaceRules.brownianMotion = audioVisualizerState.bass * 60.0 * reactivity; 
                    spaceRules.vortex = audioVisualizerState.bass * 3.0 * reactivity; 
                    
                    // --- Color from Spectral Flux ---
                    particles.forEach(p => {
                        // Bass shifts the hue from its base color
                        const hueShift = (audioVisualizerState.bass - 0.2) * 360 * reactivity;
                        const newHue = (p.type.hue + hueShift + 360) % 360;

                        // Mids control the brightness
                        let newLightness = 40 + (audioVisualizerState.mids * 50 * reactivity);

                        // Treble creates flashes of bright light
                        const flashAmount = Math.max(0, (audioVisualizerState.treble - 0.5)) * reactivity;
                        if (flashAmount > 0.05) {
                           newLightness = Math.min(100, newLightness + (100 - newLightness) * flashAmount * 2);
                        }
                        
                        // Apply the new color with a fixed high saturation
                        p.color = `hsl(${newHue}, 90%, ${newLightness}%)`;
                    });
                    break;
            }
        }
        //endregion

        // --- Initial Setup and Game Loop ---
        
        function setup(seed = null, isReplay = false) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            resetSimulationState(isReplay);

            const resetView = isInitialLoad || seed != null;

            if (isReplay) {
                // The initialConditions object is preserved from the last full setup.
            } else if (seed) {
                loadFromSeed(seed);
            } else {
                // --- New SÃ©ance Generation ---
                // 1. Check for SPECIAL anomalies first, as they alter the setup.
                initialConditions.specialAnomalyId = null;
                const SPECIAL_ANOMALY_CHANCE = 0.001; // 0.1% chance
                if (Math.random() < SPECIAL_ANOMALY_CHANCE) {
                    const specialAnomalies = ['strange_attractor', 'strange_repulsor', 'odd_particle'];
                    initialConditions.specialAnomalyId = specialAnomalies[Math.floor(Math.random() * specialAnomalies.length)];
                }

                // 2. Generate particle types.
                const numTypes = parseInt(gameSettingsPanel.querySelector('#particleTypeCountGroup .config-button.active').dataset.value, 10);
                initialConditions.particleTypes = generateParticleTypes(numTypes, cosmeticRules.colorPalette);
                
                // 3. If a special anomaly exists, add its unique type.
                if (initialConditions.specialAnomalyId) {
                    applySpecialAnomalyToInitialConditions(initialConditions);
                }

                // 4. Generate interaction rules for ALL types.
                initialConditions.interactionRules = generateInteractionRules(initialConditions.particleTypes);
                
                // 5. If a special anomaly exists, override its specific interaction rules.
                if (initialConditions.specialAnomalyId) {
                    overrideInteractionRulesForSpecialAnomaly(initialConditions);
                }
                
                // Capture the current state of cosmetics for the seed/replay
                initialConditions.cosmeticRules = { ...cosmeticRules };
                initialConditions.cosmeticRules.backgroundColor = backgroundSettings.color;
                
                // 6. Check for regular anomalies.
                initialConditions.activeAnomaly = null;
                if (Math.random() < anomalySettings.frequency) {
                    const anomaly = ALL_ANOMALIES[Math.floor(Math.random() * ALL_ANOMALIES.length)];
                    initialConditions.activeAnomaly = anomaly; 
                    showAnomalyModal(anomaly);
                }
            }
            
            // Apply the determined conditions
            Object.assign(cosmeticRules, initialConditions.cosmeticRules);
            if (initialConditions.cosmeticRules.backgroundColor) {
                backgroundSettings.color = initialConditions.cosmeticRules.backgroundColor;
            }
            
            // Apply inherent law settings from UI to the spaceRules for the new simulation
            spaceRules.predation = inherentLawSettings.predation;
            spaceRules.criticalMass = inherentLawSettings.criticalMass ? 20 : Infinity;
            spaceRules.createGhosts = inherentLawSettings.createGhosts;
            spaceRules.inertia = inherentLawSettings.inertia;
            spaceRules.chainReaction = inherentLawSettings.chainReaction;
            spaceRules.thermalShock = inherentLawSettings.thermalShock;

            particleTypes = initialConditions.particleTypes;
            interactionRules = initialConditions.interactionRules;
            
            maxParticles = parseInt(gameSettingsPanel.querySelector('#particleLimitRange').value, 10);
            
            const mapSize = gameSettingsPanel.querySelector('#mapSizeGroup .config-button.active').dataset.value;
            const shape = cosmeticRules.containmentGeometry;

            let baseDimension;
            switch(mapSize) {
                case 'vsmall': baseDimension = 400; break;
                case 'small': baseDimension = 800; break;
                case 'medium': baseDimension = 1200; break;
                case 'large': baseDimension = 1600; break;
                case 'vlarge': baseDimension = 2400; break;
                default: baseDimension = 1200; break;
            }

            switch(shape) {
                case 'vertical':
                    worldWidth = baseDimension;
                    worldHeight = baseDimension * 1.5;
                    break;
                case 'horizontal':
                    worldWidth = baseDimension * 1.5;
                    worldHeight = baseDimension;
                    break;
                case 'square':
                case 'circle':
                case 'torus':
                case 'pillar':
                case 'ouroboros':
                case 'triangle':
                case 'lemniscate':
                    worldWidth = baseDimension;
                    worldHeight = baseDimension;
                    break;
                default: // Fallback to vertical
                    worldWidth = baseDimension;
                    worldHeight = baseDimension * 1.5;
                    break;
            }

            setupCosmeticControls(); // This ensures UI matches the seed/replay's cosmetics
            generateCosmetics();
            populateParticles(Math.min(200, maxParticles / 4));
            
            // Spawn the special particle if the universe calls for it
            if (initialConditions.specialAnomalyId) {
                const specialType = particleTypes.find(t => t.isSpecial);
                if (specialType) {
                    let options = { isSpecial: true };
                    if (initialConditions.specialAnomalyId === 'odd_particle') {
                        options.isOdd = true;
                    }
                    createParticle(worldWidth / 2, worldHeight / 2, specialType, options);
                }
            }
            
            // Apply the active anomaly, if it exists
            activeAnomaly = initialConditions.activeAnomaly;
            if (activeAnomaly) {
                activeAnomaly.apply();
            }
            setupAnomalyDisplay(); // Update the UI to show the anomaly

            // Special handling for Torus geometry
            handleGeometryAnomalyInteraction(shape);

            resizeCanvas(resetView);
            isInitialLoad = false;
            if (isPaused && !document.getElementById('title-screen-overlay').classList.contains('hidden')) {
                // Do nothing, keep it paused behind title screen
            } else if (isPaused) {
                togglePause(); // Unpause if it was paused for other reasons
            }
            animate();
        }

        function resetSimulationState(keepInitialConditions = false) {
          nextParticleId = 0;
            particles = [];
            particleTypes = [];
            interactionRules = {};
            stars = [];
            activeAnomaly = null;
            // Un-apply all possible anomalies by resetting to default
            spaceRules = { ...DEFAULT_SPACE_RULES };
            if (!keepInitialConditions) {
                initialConditions = {};
            }
        }

        function animate() {
            if (!isPaused) {
                if (audioVisualizerState.enabled) {
                    updateAudioVisuals();
                }
                update();
            }
            draw();
            animationFrameId = requestAnimationFrame(animate);
        }

        let loggedInitialConditions = false;
        
        function update() {
            if (!loggedInitialConditions) {
                console.log(interactionRules)
                console.log(spaceRules)
                console.log(cosmeticRules)
                console.log(fundamentalSettings)
                console.log(inherentLawSettings)
                console.log(autoResetSettings)
                console.log(particleTypes)
                console.log(particles)
                
                
                loggedInitialConditions = true;
            }
            
            let particlesToRemove = new Set();
            let particlesToAdd = [];
            let explosionEvents = [];

            // 1. Clear and build the spatial hash based on current positions.
            // OPTIMIZATION: Use a classic for loop for performance.
            spatialHash.clear();
            for (let i = 0, len = particles.length; i < len; i++) {
                spatialHash.addToCell(particles[i]);
            }
            
            //region --- Phase 1: Calculate all forces and state changes ---
            // In this phase, we only update velocities (vx, vy), not positions (x, y).
            // OPTIMIZATION: Use a classic for loop for the main particle iteration.
            let pLen = particles.length;
            for (let i = 0; i < pLen; i++) {
                const p = particles[i];
                
                // If a particle is part of the "Odd" anomaly, it doesn't update physics.
                if (p.isOdd || p.isOddClone) {
                    p.vx = 0; p.vy = 0;
                    // It can still be a source of interaction, so we don't 'continue' here.
                }

                // First, calculate local density for state changes.
                p.localDensity = 0;
                const nearby = spatialHash.getNearby(p);
                for (let j = 0, nLen = nearby.length; j < nLen; j++) {
                    const other = nearby[j];
                    if (p === other) continue;
                    const distSq = (p.x - other.x) * (p.x - other.x) + (p.y - other.y) * (p.y - other.y);
                    if (distSq < 2500) { p.localDensity += 1 / (distSq + 10); }
                }
                updateParticleState(p);

                // Handle aging and decay.
                p.age++;
                if (!p.isGhost && (p.age > p.lifespan || Math.random() < spaceRules.decayRate)) {
                    if (spaceRules.createGhosts) {
                        particlesToAdd.push({ x: p.x, y: p.y, type: p.type, options: { isGhost: true, size: p.size } });
                    }
                    particlesToRemove.add(p.id);
                    continue; // Skip further calculations for this particle
                }
                if (p.isGhost && p.age > p.ghostLifespan) {
                    particlesToRemove.add(p.id);
                    continue;
                }

                // Apply environmental physics (viscosity, gravity, etc.) to velocity.
                p.temperature += (spaceRules.ambientTemperature - p.temperature) * spaceRules.heatDissipation;
                p.aether += (spaceRules.ambientAether - p.aether) * spaceRules.aetherFlux;
                if (p.aether < 0) p.aether = 0;

                let stateViscosity = spaceRules.viscosity;
                if (p.state === 'gas') stateViscosity = 1.0;
                if (p.state === 'solid') stateViscosity = 0.90;
                p.vx *= stateViscosity;
                p.vy *= stateViscosity;

                const inertiaFactor = spaceRules.inertia ? Math.max(1, p.mass) : 1;
                const buoyancyFactor = 1 + p.aether * 0.05;
                p.vy += spaceRules.gravityY / buoyancyFactor;
                p.vx += (Math.random() - 0.5) * spaceRules.brownianMotion * (p.state === 'gas' ? 2 : 1);
                p.vy += (Math.random() - 0.5) * spaceRules.brownianMotion * (p.state === 'gas' ? 2 : 1);
                p.vx += (spaceRules.backgroundCharge * p.charge) / inertiaFactor;

                if (spaceRules.vortex > 0) {
                    const dx = worldWidth / 2 - p.x;
                    const dy = worldHeight / 2 - p.y;
                    const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
                    p.vx += ((dy / dist) * spaceRules.vortex) / inertiaFactor;
                    p.vy -= ((dx / dist) * spaceRules.vortex) / inertiaFactor;
                }

                // Calculate interactions with other particles.
                // OPTIMIZATION: Use a classic for loop for iterating nearby particles.
                for (let j = 0, nLen = nearby.length; j < nLen; j++) {
                    const other = nearby[j];
                    if (p.id >= other.id) continue;
                    if (particlesToRemove.has(other.id)) continue;

                    const dx = other.x - p.x;
                    const dy = other.y - p.y;
                    let distSq = dx * dx + dy * dy;

                    if (p.isGhost || other.isGhost) {
                        if (distSq < 10000) {
                            const force = -0.1;
                            const dist = Math.max(1, Math.sqrt(distSq));
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;
                            if (!p.isGhost) { p.vx += fx; p.vy += fy; }
                            if (!other.isGhost) { other.vx -= fx; other.vy -= fy; }
                        }
                        continue;
                    }

                    if (spaceRules.enableResonanceBonding) {
                        const resonanceDiff = Math.abs(p.resonance - other.resonance);
                        if (resonanceDiff < spaceRules.resonantBondingThreshold && distSq < 150 * 150) {
                            const force = (1 - (resonanceDiff / spaceRules.resonantBondingThreshold)) * spaceRules.resonantBondingStrength;
                            const dist = Math.max(1, Math.sqrt(distSq));
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;
                            p.vx += fx / p.mass; p.vy += fy / p.mass;
                            other.vx -= fx / other.mass; other.vy -= fy / other.mass;
                        }
                    }

                    const rule = interactionRules[p.typeId][other.typeId];
                    if ((rule.behavior === 'attract' || rule.behavior === 'repel') && distSq < rule.range * rule.range) {
                        const dist = Math.max(1, Math.sqrt(distSq));
                        const force = (rule.behavior === 'attract' ? 1 : -1) * rule.force;
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        p.vx += fx / p.mass; p.vy += fy / p.mass;
                        other.vx -= fx / other.mass; other.vy -= fy / other.mass;
                    }

                    if (distSq < (p.size + other.size) * (p.size + other.size)) {
                        handleContact(p, other, particlesToRemove, particlesToAdd);
                    }
                }
            }
            //endregion

            //region --- Phase 2: Apply all calculated changes ---
            // Now that all force calculations are done, we can safely move the particles.
            // OPTIMIZATION: Use a classic for loop.
            pLen = particles.length;
            for (let i = 0; i < pLen; i++) {
                const p = particles[i];
                if (particlesToRemove.has(p.id)) continue;

                // Enforce frozen state for Odd particles just before movement
                if (p.isOdd || p.isOddClone) {
                    p.vx = 0;
                    p.vy = 0;
                }

                p.x += p.vx;
                p.y += p.vy;
                handleBoundary(p);

                if (p.size > spaceRules.criticalMass) {
                    shatter(p, particlesToAdd, 5 + Math.floor(p.size / 5));
                    particlesToRemove.add(p.id);
                    if (spaceRules.chainReaction) {
                        explosionEvents.push({ x: p.x, y: p.y });
                    }
                }
            }
            //endregion

            //region --- Phase 3: Cleanup and creation ---
            if (explosionEvents.length > 0) {
                for (let i = 0, eLen = explosionEvents.length; i < eLen; i++) {
                    const explosion = explosionEvents[i];
                    const nearbyForExplosion = spatialHash.getNearby({ x: explosion.x, y: explosion.y });
                    for (let j = 0, nLen = nearbyForExplosion.length; j < nLen; j++) {
                        const p = nearbyForExplosion[j];
                        if (particlesToRemove.has(p.id)) continue;
                        const dx = p.x - explosion.x;
                        const dy = p.y - explosion.y;
                        const distSq = dx * dx + dy * dy;
                        if (distSq < 10000 && p.size > spaceRules.criticalMass * 0.75 && Math.random() < 0.1) {
                            shatter(p, particlesToAdd, 3 + Math.floor(p.size / 5));
                            particlesToRemove.add(p.id);
                        }
                    }
                }
            }

            if (Math.random() < spaceRules.spontaneousGeneration && particles.length < maxParticles) {
                const type = particleTypes[Math.floor(Math.random() * particleTypes.length)];
                createParticle(Math.random() * worldWidth, Math.random() * worldHeight, type);
            }

            particles = particles.filter(p => !particlesToRemove.has(p.id));
            
            for (let i = 0, aLen = particlesToAdd.length; i < aLen; i++) {
                const data = particlesToAdd[i];
                createParticle(data.x, data.y, data.type, data.options);
            }
            //endregion

            // NEW: Automatic SÃ©ance Reset Logic
            if (autoResetSettings.threshold > 0 && particles.length > 0 && particles.length < maxParticles * autoResetSettings.threshold) {
                setup();
            }
        }

        //region drawFunctions
        function draw() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = cosmeticRules.backgroundStyle === 'crt_glow' ? '#1a1a1a' : backgroundSettings.color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.setTransform(viewTransform);

            // Main drawing logic is now routed through the viewer mode
            switch(cosmeticRules.viewerMode) {
                case 'aether_density':
                    drawAetherDensityView();
                    break;
                case 'doppler_shift':
                    drawDopplerShiftView();
                    break;
                case 'none':
                default:
                    drawStandardView();
                    break;
            }

            ctx.restore();
        }

        function drawStandardView() {
            let baseFill = cosmeticRules.backgroundStyle === 'crt_glow' ? '#1a1a1a' : backgroundSettings.color;
            
            // Check for audio-driven background flash
            if (audioVisualizerState.enabled && audioVisualizerState.bgFlash > 0.01) {
                const flashIntensity = Math.floor(255 * audioVisualizerState.bgFlash);
                baseFill = `rgb(${flashIntensity}, ${flashIntensity}, ${flashIntensity})`;
            }

            ctx.fillStyle = baseFill;
            ctx.fillRect(0, 0, worldWidth, worldHeight);
            ctx.globalAlpha = 1.0;

            const palette = COLOR_PALETTES[cosmeticRules.colorPalette];
            if (palette && palette.special === 'multiply') {
                ctx.globalCompositeOperation = 'multiply';
            }

            drawBackground();
            
            if (cosmeticRules.particleEffect === 'mycelium') {
                drawMyceliumNetwork();
            } else {
                particles.forEach(p => drawSingleParticle(p));
            }

            ctx.globalCompositeOperation = 'source-over';
        }

        function drawSingleParticle(p) {
            let alpha = p.isGhost ? 1 - (p.age / p.ghostLifespan) : 0.9;
            if (p.state === 'gas') alpha *= 0.7;
            if (p.state === 'solid') alpha = 1.0;
            ctx.globalAlpha = alpha;
            
            const style = p.isGhost ? 'circle' : cosmeticRules.particleStyle;
            const effect = p.isGhost ? 'glow' : cosmeticRules.particleEffect;

            // Apply effects first (like glow), then draw the particle shape on top
            applyParticleEffect(p, style, effect);
            drawParticleShape(p, style);

            ctx.shadowBlur = 0; // Ensure shadowblur is always reset
        }
        
        function drawParticleShape(p, style, forClipping = false) {
            switch(style) {
                case 'astrological_symbol': {
                    ctx.font = `${p.size * 2.5}px "Times New Roman", serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.astrologicalSymbol || '?', p.x, p.y);
                    break;
                }
                case 'rune': {
                    ctx.font = `${p.size * 2}px "UnifrakturMaguntia", cursive`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.symbol || '?', p.x, p.y);
                    break;
                }
                case 'protostar': {
                    const jitterX = (Math.random() - 0.5) * p.size * 0.2;
                    const jitterY = (Math.random() - 0.5) * p.size * 0.2;
                    const coreSize = p.size * 0.6;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(p.x + jitterX, p.y + jitterY, coreSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.3;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x + jitterX, p.y + jitterY, p.size * (1 + Math.random() * 0.2), 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }
                case 'datamosh_block': {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size, p.y - p.size / 2, p.size * 2, p.size);
                    break;
                }
                case 'scanline_error': {
                    const jitterY = p.y + (Math.random() - 0.5) * 4;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size * 2.5, jitterY - 1, p.size * 5, 2);
                    break;
                }
                case 'core':
                    ctx.fillStyle = p.color;  
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.4;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                    break;
                case 'ringed':
                    ctx.strokeStyle = p.color; ctx.lineWidth = Math.max(1, p.size * 0.2);
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size - ctx.lineWidth/2, 0, Math.PI * 2); ctx.stroke();
                    break;
                case 'glitch':
                    ctx.fillStyle = p.color;
                    const offset1 = (Math.random() - 0.5) * p.size * 0.5;
                    const offset2 = (Math.random() - 0.5) * p.size * 0.5;
                    ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.6;
                    ctx.fillRect(p.x - p.size/2 + offset1, p.y - p.size/2, p.size, p.size);
                    ctx.fillStyle = `hsl(${ (p.type.hue || 180) + 180}, 100%, 70%)`;
                    ctx.fillRect(p.x - p.size/2 + offset2, p.y - p.size/2, p.size, p.size);
                    break;
                case 'symbol':
                    ctx.font = `${p.size * 2}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.symbol || '?', p.x, p.y);
                    break;
                case 'square':
                    if (forClipping) { ctx.beginPath(); ctx.rect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); }
                    else { ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); }
                    break;
                case 'cross':
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = p.size * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(p.x - p.size, p.y);
                    ctx.lineTo(p.x + p.size, p.y);
                    ctx.moveTo(p.x, p.y - p.size);
                    ctx.lineTo(p.x, p.y + p.size);
                    ctx.stroke();
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y - p.size);
                    ctx.lineTo(p.x + p.size * 0.866, p.y + p.size * 0.5);
                    ctx.lineTo(p.x - p.size * 0.866, p.y + p.size * 0.5);
                    ctx.closePath();
                    if (!forClipping) { ctx.fillStyle = p.color; ctx.fill(); }
                    break;
                case 'ascii':
                    ctx.font = `${p.size * 2}px "VT323", monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.symbol || '@', p.x, p.y);
                    break;
                case 'i-ching':
                    ctx.font = `${p.size * 2}px "Roboto Mono", monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.symbol || 'â˜°', p.x, p.y);
                    break;
                case 'ink_stroke': {
                    const speed = Math.sqrt(p.vx**2 + p.vy**2);
                    const thickness = Math.max(1, p.size * (1 - Math.min(1, speed / 5)));
                    const length = p.size + speed * 2;
                    const angle = Math.atan2(p.vy, p.vx);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(p.x - Math.cos(angle) * length / 2, p.y - Math.sin(angle) * length / 2);
                    ctx.lineTo(p.x + Math.cos(angle) * length / 2, p.y + Math.sin(angle) * length / 2);
                    ctx.stroke();
                    break;
                }
                case 'tiny_square': {
                    const tinySize = p.size * 0.25; // Made smaller
                    if (forClipping) { 
                        ctx.beginPath(); 
                        ctx.rect(p.x - tinySize / 2, p.y - tinySize / 2, tinySize, tinySize); 
                    } else { 
                        ctx.fillStyle = p.color; 
                        ctx.fillRect(p.x - tinySize / 2, p.y - tinySize / 2, tinySize, tinySize); 
                    }
                    break;
                }
                case 'tiny_ink_stroke': {
                    const speed = Math.sqrt(p.vx**2 + p.vy**2);
                    const thickness = Math.max(0.5, (p.size * 0.2) * (1 - Math.min(1, speed / 5))); // Made smaller
                    const length = (p.size * 0.3) + speed * 1.5; // Made smaller
                    const angle = Math.atan2(p.vy, p.vx);

                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = thickness;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(p.x - Math.cos(angle) * length / 2, p.y - Math.sin(angle) * length / 2);
                    ctx.lineTo(p.x + Math.cos(angle) * length / 2, p.y + Math.sin(angle) * length / 2);
                    ctx.stroke();
                    break;
                }
                case 'circle':
                case 'hard':
                default:
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    if (!forClipping) ctx.fill();
                    break;
            }
        }
        
        function applyParticleEffect(p, style, effect) {
            // Helper function for the new optimized glow
            const drawGlow = (radius, alpha) => {
                const glowGradient = ctx.createRadialGradient(p.x, p.y, p.size * 0.2, p.x, p.y, radius);
                glowGradient.addColorStop(0, p.color);
                glowGradient.addColorStop(1, 'transparent');
                
                const originalAlpha = ctx.globalAlpha;
                ctx.globalAlpha = originalAlpha * alpha;
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = originalAlpha; // Restore alpha for the main particle draw
            };

            switch(effect) {
                // NOTE: 'mycelium' is handled in the main draw loop, not here.
                case 'glow':
                    drawGlow(p.size * 2.5, 0.7);
                    break;
                case 'soft-glow':
                    drawGlow(p.size * 4.0, 0.6);
                    break;
                case 'pulse-glow':
                    const pulse = 0.5 + Math.sin(p.age * 0.05) * 0.5; // 0 to 1 cycle
                    const pulseRadius = p.size * (2.0 + pulse * 2.5);
                    drawGlow(pulseRadius, 0.65);
                    break;

                case 'afterimage_trail': {
                    const speed = Math.sqrt(p.vx**2 + p.vy**2);
                    if (speed < 0.5) break;
                    const originalAlpha = ctx.globalAlpha;
                    const trailLength = 5;
                    for (let i = 1; i <= trailLength; i++) {
                        const progress = i / trailLength;
                        ctx.globalAlpha = originalAlpha * (1 - progress) * 0.5;
                        const trailX = p.x - p.vx * i * 2;
                        const trailY = p.y - p.vy * i * 2;
                        const tempParticle = { ...p, x: trailX, y: trailY, size: p.size * (1 - progress * 0.5) };
                        drawParticleShape(tempParticle, style);
                    }
                    ctx.globalAlpha = originalAlpha;
                    break;
                }
                case 'directional_cone': {
                    const speed = Math.sqrt(p.vx**2 + p.vy**2);
                    if (speed < 1) break;
                    const coneLength = Math.min(50, p.size + speed * 5);
                    const coneWidth = p.size * 1.5;
                    const angle = Math.atan2(p.vy, p.vx);

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = (ctx.globalAlpha || 1) * Math.min(0.5, speed / 10);

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-coneLength, -coneWidth / 2);
                    ctx.lineTo(-coneLength, coneWidth / 2);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                    break;
                }
                case 'lenticular': {
                    const angle = Math.atan2(p.vy, p.vx);
                    const lightnessMod = Math.sin(angle * 2) * 15;
                    const baseLightness = 60;
                    const finalLightness = Math.max(10, Math.min(90, baseLightness + lightnessMod));
                    ctx.fillStyle = `hsl(${p.type.hue}, 90%, ${finalLightness}%)`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }
                case 'translucent':
                    ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.25;
                    drawParticleShape(p, style);
                    ctx.globalAlpha = (ctx.globalAlpha || 1) * 0.8;
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 1;
                    break;
                case 'scanlines': {
                    ctx.save();
                    drawParticleShape(p, style, true); // Create clipping path
                    ctx.clip();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = Math.max(1, p.size * 0.1);
                    for(let y = p.y - p.size; y < p.y + p.size; y += p.size * 0.25) {
                        ctx.beginPath();
                        ctx.moveTo(p.x - p.size, y);
                        ctx.lineTo(p.x + p.size, y);
                        ctx.stroke();
                    }
                    ctx.restore();
                    break;
                }
                case 'chromatic_aberration': {
                    const speed = Math.sqrt(p.vx**2 + p.vy**2);
                    if (speed > 2.5) {
                        ctx.save();
                        const offset = speed * 0.5;
                        ctx.globalCompositeOperation = 'lighter';
                        
                        ctx.fillStyle = 'rgb(255,0,0)';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.arc(p.x - offset, p.y, p.size, 0, Math.PI * 2); ctx.fill();

                        ctx.fillStyle = 'rgb(0,255,0)';
                        ctx.beginPath(); ctx.arc(p.x, p.y - offset, p.size, 0, Math.PI * 2); ctx.fill();

                        ctx.fillStyle = 'rgb(0,0,255)';
                        ctx.beginPath(); ctx.arc(p.x + offset * 0.5, p.y + offset * 0.5, p.size, 0, Math.PI * 2); ctx.fill();

                        ctx.restore();
                    }
                    break;
                }
            }
        }
        //endregion

        // --- Generation and State Management ---
        function generateParticleTypes(numTypes, paletteId = 'random_colors') {
            const types = [];
            const palette = COLOR_PALETTES[paletteId];
            
            if (paletteId === 'random_colors') {
                const GOLDEN_ANGLE = 137.5;
                let currentHue = Math.random() * 360;
                for (let i = 0; i < numTypes; i++) {
                    types.push({
                        id: i, name: `Entity ${String.fromCharCode(65 + i)}`,
                        color: `hsl(${currentHue}, ${50 + Math.random() * 50}%, ${60 + Math.random() * 15}%)`,
                        baseSize: 6 + Math.random() * 24,
                        massFactor: 0.2 + Math.random() * 2.8,
                        chargeFactor: (Math.random() - 0.5) * 8,
                        tempRange: [Math.random() * 100 - 20, 80 + Math.random() * 100],
                        aetherRange: [Math.random() * 60, 60 + Math.random() * 80],
                        baseLifespanFactor: 0.5 + Math.random() * 2.5,
                        hue: currentHue,
                    });
                    currentHue = (currentHue + GOLDEN_ANGLE) % 360;
                }
                return types;
            }
            
            if (paletteId === 'true_random_colors') {
                for (let i = 0; i < numTypes; i++) {
                    const hue = Math.random() * 360;
                    types.push({
                        id: i, name: `Entity ${String.fromCharCode(65 + i)}`,
                        color: `hsl(${hue}, ${20 + Math.random() * 80}%, ${30 + Math.random() * 60}%)`,
                        baseSize: 6 + Math.random() * 24,
                        massFactor: 0.2 + Math.random() * 2.8,
                        chargeFactor: (Math.random() - 0.5) * 8,
                        tempRange: [Math.random() * 100 - 20, 80 + Math.random() * 100],
                        aetherRange: [Math.random() * 60, 60 + Math.random() * 80],
                        baseLifespanFactor: 0.5 + Math.random() * 2.5,
                        hue: hue,
                    });
                }
                return types;
            }

            if (palette.colors) { // Handle fixed color palettes
                for (let i = 0; i < numTypes; i++) {
                    const color = palette.colors[i % palette.colors.length];
                    const hsl = hexToHsl(color);
                    types.push({
                        id: i, name: `Entity ${String.fromCharCode(65 + i)}`,
                        color: color,
                        baseSize: 6 + Math.random() * 24,
                        massFactor: 0.2 + Math.random() * 2.8,
                        chargeFactor: (Math.random() - 0.5) * 8,
                        tempRange: [Math.random() * 100 - 20, 80 + Math.random() * 100],
                        aetherRange: [Math.random() * 60, 60 + Math.random() * 80],
                        baseLifespanFactor: 0.5 + Math.random() * 2.5,
                        hue: hsl ? hsl[0] : 0,
                    });
                }
                return types;
            }

            let baseHue;
            if (paletteId === 'monochrome') {
                baseHue = Math.random() * 360;
            }

            for (let i = 0; i < numTypes; i++) {
                let hue, sat, light;

                if (paletteId === 'monochrome') {
                    hue = baseHue;
                    sat = 10 + Math.random() * 80;
                    light = 20 + Math.random() * 70;
                } else {
                    if (!palette || !palette.hueRange) { // Fallback
                        hue = Math.random() * 360; sat = 50; light = 50;
                    } else {
                        const [hMin, hMax] = palette.hueRange;
                        const [sMin, sMax] = palette.satRange;
                        const [lMin, lMax] = palette.lightRange;
                        const hueRangeSize = hMax - hMin;
                        const hueSegment = numTypes > 1 ? hueRangeSize / (numTypes - 1) : hueRangeSize / 2;
                        hue = hMin + (i * hueSegment);
                        if (hue < 0) hue += 360;
                        hue %= 360;
                        sat = sMin + Math.random() * (sMax - sMin);
                        light = lMin + Math.random() * (lMax - lMin);
                    }
                }
                
                types.push({
                    id: i, name: `Entity ${String.fromCharCode(65 + i)}`,
                    color: `hsl(${hue}, ${sat}%, ${light}%)`,
                    baseSize: 6 + Math.random() * 24,
                    massFactor: 0.2 + Math.random() * 2.8,
                    chargeFactor: (Math.random() - 0.5) * 8,
                    tempRange: [Math.random() * 100 - 20, 80 + Math.random() * 100],
                    aetherRange: [Math.random() * 60, 60 + Math.random() * 80],
                    baseLifespanFactor: 0.5 + Math.random() * 2.5,
                    hue: hue,
                });
            }
            return types;
        }

        function generateInteractionRules(types) {
            const rules = {};
            
            let availableBehaviors = [...BEHAVIORS];
            if (!fundamentalSettings.allowMutate) {
                availableBehaviors = availableBehaviors.filter(b => b !== 'mutate');
            }
            if (!fundamentalSettings.allowDrain) {
                availableBehaviors = availableBehaviors.filter(b => b !== 'drain');
            }
            if (availableBehaviors.length === 0) {
                availableBehaviors.push('ignore');  
            }

            types.forEach(typeA => {
                rules[typeA.id] = {};
                types.forEach(typeB => {
                    rules[typeA.id][typeB.id] = {
                        behavior: availableBehaviors[Math.floor(Math.random() * availableBehaviors.length)],
                        force: (Math.random() - 0.5) * 5,
                        range: 10 + Math.random() * 450
                    };
                });
            });
            return rules;
        }

        function populateParticles(count) {
            for (let i = 0; i < count; i++) {
                const regularTypes = particleTypes.filter(t => !t.isSpecial);
                if (regularTypes.length === 0) continue;
                createParticle(
                    Math.random() * worldWidth,
                    Math.random() * worldHeight,
                    regularTypes[Math.floor(Math.random() * regularTypes.length)]
                );
            }
        }

        function createParticle(x, y, type, options = {}) {
            if (particles.length >= maxParticles) return;

            const size = options.size || (type.baseSize * (0.8 + Math.random() * 0.4));
            const isFragment = options.isFragment || false;
            
            const baseLifespan = isFragment    
                ? (250 + Math.random() * 350)  
                : (5000 + size * 500) * (type.baseLifespanFactor || 1) + Math.random() * 2000;
            
            let lifespanFactor = fundamentalSettings.longLifespan ? 4 : 1;
            if (options.isSpecial || options.isOdd || options.isOddClone) {
                lifespanFactor = Number.MAX_SAFE_INTEGER;
            }
            
            const randomInRange = (range) => range[0] + Math.random() * (range[1] - range[0]);
            let symbol, astrologicalSymbol;
            const currentStyle = cosmeticRules.particleStyle;

            if (currentStyle === 'ascii') {
                symbol = ASCII_CHARS[Math.floor(Math.random() * ASCII_CHARS.length)];
            } 
            else if (currentStyle === 'i-ching') {
                symbol = I_CHING_TRIGRAMS[Math.floor(Math.random() * I_CHING_TRIGRAMS.length)];
            } else if (currentStyle === 'rune') {
                symbol = RUNE_SYMBOLS[Math.floor(Math.random() * RUNE_SYMBOLS.length)];
            } else if (currentStyle === 'astrological_symbol') {
                astrologicalSymbol = ASTROLOGICAL_SYMBOLS[Math.floor(Math.random() * ASTROLOGICAL_SYMBOLS.length)];
            } else {
                symbol = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
            }
          particles.push({
                id: nextParticleId++, x, y,
                vx: options.vx || (Math.random() - 0.5) * 2,
                vy: options.vy || (Math.random() - 0.5) * 2,
                size: Math.min(size, MAX_PARTICLE_SIZE),
                mass: size * size * 0.1 * (type.massFactor || 1),
                typeId: type.id, color: type.color, type: type,
                charge: options.charge || (type.chargeFactor || 0) * (0.5 + Math.random()),
                temperature: options.temperature || (type.tempRange ? randomInRange(type.tempRange) : (Math.random() * 120)),
                aether: options.aether || (type.aetherRange ? randomInRange(type.aetherRange) : (Math.random() * 80 + 10)),
                resonance: options.resonance || Math.random(),
                state: 'liquid',
                localDensity: 0,
                age: 0,
                lifespan: lifespanFactor === Number.MAX_SAFE_INTEGER ? lifespanFactor : baseLifespan * lifespanFactor,
                isGhost: options.isGhost || false,
                ghostLifespan: 200,
                isOdd: options.isOdd || false,
                isOddClone: options.isOddClone || false,
                symbol: symbol,
                astrologicalSymbol: astrologicalSymbol,
            });
        }

        function shatter(parent, particlesToAdd, numFragments) {
            for (let i = 0; i < numFragments; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                particlesToAdd.push({
                    x: parent.x, y: parent.y, type: parent.type,
                    options: {
                        size: Math.max(4.5, parent.size / Math.sqrt(numFragments)),
                        vx: parent.vx + Math.cos(angle) * speed,
                        vy: parent.vy + Math.sin(angle) * speed,
                        charge: parent.charge + (Math.random() - 0.5) * 0.2,
                        temperature: parent.temperature + 20,
                        aether: parent.aether / numFragments,
                        resonance: parent.resonance + (Math.random() - 0.5) * 0.1,
                        isFragment: true,
                    }
                });
            }
        }

        function updateParticleState(p) {
            const temp = p.temperature;
            const density = p.localDensity;
            const factor = spaceRules.stateChangeFactor;

            if (temp > 80 * factor || density < 0.05 * factor) { p.state = 'gas'; }    
            else if (temp < 20 * factor && density > 0.5 * factor) { p.state = 'solid'; }
            else { p.state = 'liquid'; }
        }

        function handleContact(p1, p2, particlesToRemove, particlesToAdd) {
            // Handle "Odd Particle" infection first, as it overrides all other interactions.
            const isP1OddLike = p1.isOdd || p1.isOddClone;
            const isP2OddLike = p2.isOdd || p2.isOddClone;

            if (isP1OddLike && !isP2OddLike) { // p1 infects p2
                p2.isOddClone = true;
                p2.lifespan = Number.MAX_SAFE_INTEGER;
                p2.color = p1.color;
                p2.typeId = p1.typeId;
                p2.type = p1.type;
                return; // Infection is the only interaction.
            } else if (isP2OddLike && !isP1OddLike) { // p2 infects p1
                p1.isOddClone = true;
                p1.lifespan = Number.MAX_SAFE_INTEGER;
                p1.color = p2.color;
                p1.typeId = p2.typeId;
                p1.type = p2.type;
                return; // Infection is the only interaction.
            } else if (isP1OddLike && isP2OddLike) {
                return; // Two infected particles do nothing to each other.
            }

            if (particlesToRemove.has(p1.id) || particlesToRemove.has(p2.id)) return;
            if (spaceRules.enableDissonance) {
                const resonanceDiff = Math.abs(p1.resonance - p2.resonance);
                if (resonanceDiff > spaceRules.dissonanceThreshold) {
                    const unstable = p1.aether < p2.aether ? p1 : p2;
                    const stable = p1.aether < p2.aether ? p2 : p1;
                    shatter(unstable, particlesToAdd, 4);
                    stable.aether += unstable.aether * 0.5;
                    particlesToRemove.add(unstable.id);
                    return;
                }
            }
            
            if (spaceRules.predation) {
                const smaller = p1.size < p2.size ? p1 : p2;
                const larger = p1.size < p2.size ? p2 : p1;
                larger.size = Math.min(MAX_PARTICLE_SIZE, Math.sqrt(larger.size*larger.size + smaller.size*smaller.size));
                larger.mass += smaller.mass;
                larger.aether += smaller.aether;
                particlesToRemove.add(smaller.id);
                return; 
            }

            const rule = interactionRules[p1.typeId][p2.typeId];
            if (Math.random() < 0.2) {   
                switch (rule.behavior) {
                    case 'aether_siphon': {
                        const siphonAmount = Math.min(p2.aether * 0.1, 1.0);
                        if (p2.aether > 1) { p2.aether -= siphonAmount; p1.aether += siphonAmount; }
                        break;
                    }
                    case 'mutate': {
                        const newType = particleTypes[Math.floor(Math.random() * particleTypes.length)];
                        p1.type = newType; p1.typeId = newType.id; p1.color = newType.color;
                        break;
                    }
                    case 'merge': {
                        const newSize = Math.min(MAX_PARTICLE_SIZE, Math.sqrt(p1.size*p1.size + p2.size*p2.size));
                        const newType = p1.mass > p2.mass ? p1.type : p2.type;
                        const newAether = p1.aether + p2.aether;
                        const newResonance = (p1.resonance * p1.mass + p2.resonance * p2.mass) / (p1.mass + p2.mass);
                        particlesToAdd.push({ x:(p1.x + p2.x)/2, y:(p1.y + p2.y)/2, type: newType, options: { size: newSize, aether: newAether, resonance: newResonance } });
                        particlesToRemove.add(p1.id).add(p2.id);
                        return;
                    }
                    case 'shatter': {
                        shatter(p1, particlesToAdd, 3);
                        particlesToRemove.add(p1.id);
                        return; 
                    }
                    case 'drain': {
                        const drainAmount = Math.min(p2.size * 0.1, 0.5);
                        if (p2.size > 1) { p2.size -= drainAmount; p1.size += drainAmount; }
                        p1.size = Math.min(MAX_PARTICLE_SIZE, p1.size);
                        break;
                    }
                    case 'charge_transfer': {
                        const avgCharge = (p1.charge + p2.charge) / 2;
                        p1.charge = avgCharge; p2.charge = avgCharge;
                        break;
                    }
                    case 'heat_transfer': {
                        const oldTemp1 = p1.temperature;
                        const oldTemp2 = p2.temperature;
                        const avgTemp = (p1.temperature * p1.mass + p2.temperature * p2.mass) / (p1.mass + p2.mass);
                        p1.temperature = avgTemp;
                        p2.temperature = avgTemp;
                        
                        if (spaceRules.thermalShock) {
                            if (Math.abs(oldTemp1 - avgTemp) > 35 && Math.random() < 0.25) {
                                shatter(p1, particlesToAdd, 2);
                                particlesToRemove.add(p1.id);
                            }
                            if (Math.abs(oldTemp2 - avgTemp) > 35 && Math.random() < 0.25) {
                                shatter(p2, particlesToAdd, 2);
                                particlesToRemove.add(p2.id);
                            }
                        }
                        break;
                    }
                }
            }

            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            const normalX = dx / dist, normalY = dy / dist;
            const p = (1 + spaceRules.elasticity) * (p1.vx * normalX + p1.vy * normalY - p2.vx * normalX - p2.vy * normalY) / (p1.mass + p2.mass);
            p1.vx -= p * p2.mass * normalX; p1.vy -= p * p2.mass * normalY;
            p2.vx += p * p1.mass * normalX; p2.vy += p * p1.mass * normalY;
        }

        //region Boundaries
        /**
         * NEW: This function routes the particle to the correct boundary handling
         * logic based on the currently selected containment geometry.
         */

        function handleBoundary(p) {
            const shape = cosmeticRules.containmentGeometry;

            if (shape === 'torus' || spaceRules.boundary === 'wrap') {
                handleTorusBoundary(p);
            } else if (shape === 'circle') {
                handleCircleBoundary(p);
            } else if (shape === 'ouroboros') {
                handleOuroborosBoundary(p);
            } else if (shape === 'triangle') {
                handleTriangleBoundary(p);
            } else if (shape === 'lemniscate') {
                handleLemniscateBoundary(p);
            } else { // Default for vertical, horizontal, square, pillar
                handleRectangleBoundary(p);
                // Additional checks for internal barriers
                if (shape === 'pillar') handlePillarBarrier(p);
            }
        }

        /** NEW: Handles standard rectangular boundary with bouncing. */
        function handleRectangleBoundary(p) {
            if ((p.x < p.size && p.vx < 0) || (p.x > worldWidth - p.size && p.vx > 0)) {
                p.vx *= -spaceRules.elasticity;
            }
            if ((p.y < p.size && p.vy < 0) || (p.y > worldHeight - p.size && p.vy > 0)) {
                p.vy *= -spaceRules.elasticity;
            }
            p.x = Math.max(p.size, Math.min(p.x, worldWidth - p.size));
            p.y = Math.max(p.size, Math.min(p.y, worldHeight - p.size));
        }

        /** NEW: Handles circular boundary with bouncing. */
        function handleCircleBoundary(p) {
            const centerX = worldWidth / 2;
            const centerY = worldHeight / 2;
            const radius = worldWidth / 2;
            const dx = p.x - centerX;
            const dy = p.y - centerY;
            const distanceSq = dx * dx + dy * dy;

            if (distanceSq > (radius - p.size) * (radius - p.size)) {
                const distance = Math.sqrt(distanceSq);
                const normalX = dx / distance;
                const normalY = dy / distance;
                const dot = p.vx * normalX + p.vy * normalY;

                p.vx -= 2 * dot * normalX;
                p.vy -= 2 * dot * normalY;
                p.vx *= spaceRules.elasticity;
                p.vy *= spaceRules.elasticity;

                const overlap = distance - (radius - p.size);
                p.x -= overlap * normalX;
                p.y -= overlap * normalY;
            }
        }
        
        /** NEW: Handles wrap-around (torus) boundary. */
        function handleTorusBoundary(p) {
            if (p.x < -p.size) p.x = worldWidth + p.size;
            if (p.x > worldWidth + p.size) p.x = -p.size;
            if (p.y < -p.size) p.y = worldHeight + p.size;
            if (p.y > worldHeight + p.size) p.y = -p.size;
        }

        /** NEW: Handles collision with the central pillar. */
        function handlePillarBarrier(p) {
            const pillarRadius = worldWidth * 0.1;
            const centerX = worldWidth / 2;
            const centerY = worldHeight / 2;
            const dx = p.x - centerX;
            const dy = p.y - centerY;
            const distanceSq = dx * dx + dy * dy;

            if (distanceSq < (pillarRadius + p.size) * (pillarRadius + p.size)) {
                const distance = Math.sqrt(distanceSq);
                // Reflect outwards, opposite of the circle boundary
                const normalX = dx / distance;
                const normalY = dy / distance;
                const dot = p.vx * normalX + p.vy * normalY;

                p.vx -= 2 * dot * normalX;
                p.vy -= 2 * dot * normalY;
                p.vx *= spaceRules.elasticity;
                p.vy *= spaceRules.elasticity;

                // Move particle outside the pillar
                const overlap = (pillarRadius + p.size) - distance;
                p.x += overlap * normalX;
                p.y += overlap * normalY;
            }
        }
        
        /** NEW: Handles Ouroboros boundary (outer circle, inner pillar). Renamed from Donut. */
        function handleOuroborosBoundary(p) {
            handleCircleBoundary(p); // Outer boundary
            const pillarRadius = worldWidth * 0.25; // A larger inner circle for the ouroboros effect
            const centerX = worldWidth / 2;
            const centerY = worldHeight / 2;
            const dx = p.x - centerX;
            const dy = p.y - centerY;
            const distanceSq = dx * dx + dy * dy;

            if (distanceSq < (pillarRadius + p.size) * (pillarRadius + p.size)) {
                const distance = Math.sqrt(distanceSq);
                const normalX = dx / distance;
                const normalY = dy / distance;
                const dot = p.vx * normalX + p.vy * normalY;

                p.vx -= 2 * dot * normalX;
                p.vy -= 2 * dot * normalY;
                p.vx *= spaceRules.elasticity;
                p.vy *= spaceRules.elasticity;

                const overlap = (pillarRadius + p.size) - distance;
                p.x += overlap * normalX;
                p.y += overlap * normalY;
            }
        }
        
        /** FIXED: Handles triangular boundary. */
        function handleTriangleBoundary(p) {
            const h = worldHeight * (Math.sqrt(3) / 2); // Height of an equilateral triangle
            const centerX = worldWidth / 2;
            const topY = (worldHeight - h) / 2;

            // Define vertices in counter-clockwise (CCW) order for inward normals
            const p1 = { x: centerX, y: topY }; // Top vertex
            const p2 = { x: centerX - worldWidth / 2, y: topY + h }; // Bottom-left
            const p3 = { x: centerX + worldWidth / 2, y: topY + h }; // Bottom-right

            const lines = [
                { p1: p1, p2: p2 }, // Left edge
                { p1: p2, p2: p3 }, // Bottom edge
                { p1: p3, p2: p1 }  // Right edge
            ];

            for (const line of lines) {
                const lineDX = line.p2.x - line.p1.x;
                const lineDY = line.p2.y - line.p1.y;

                // Inward-pointing normal for a CCW polygon edge
                const normalX = lineDY;
                const normalY = -lineDX;
                
                const len = Math.sqrt(normalX * normalX + normalY * normalY);
                const nx = normalX / len;
                const ny = normalY / len;

                // Project particle's center onto the normal
                const dist = (p.x - line.p1.x) * nx + (p.y - line.p1.y) * ny;

                // Check for collision (particle is "outside" the line)
                if (dist < p.size) {
                    // Project velocity onto the normal
                    const dot = p.vx * nx + p.vy * ny;
                    
                    // If moving towards the wall, reflect it
                    if (dot < 0) {
                        p.vx -= (1 + spaceRules.elasticity) * dot * nx;
                        p.vy -= (1 + spaceRules.elasticity) * dot * ny;
                    }
                    
                    // Push particle out to prevent it from getting stuck
                    const overlap = p.size - dist;
                    p.x += overlap * nx;
                    p.y += overlap * ny;
                }
            }
        }

        /** NEW: Handles lemniscate (infinity symbol) boundary. */
        function handleLemniscateBoundary(p) {
            const centerX = worldWidth / 2;
            const centerY = worldHeight / 2;
            const a = worldWidth / 2.5; // Scale factor for the lemniscate

            const x = p.x - centerX;
            const y = p.y - centerY;

            const r2 = x * x + y * y;
            const val = r2 * r2 - 2 * a * a * (x * x - y * y);

            if (val > 0) { // Particle is outside the lemniscate
                // Gradient of the implicit function gives the normal direction
                const normalX = 4 * x * r2 - 4 * a * a * x;
                const normalY = 4 * y * r2 + 4 * a * a * y;
                const len = Math.sqrt(normalX * normalX + normalY * normalY);
                if (len === 0) return; // Avoid division by zero at the singularity
                const nx = normalX / len;
                const ny = normalY / len;

                const dot = p.vx * nx + p.vy * ny;
                if (dot > 0) {
                    p.vx -= (1 + spaceRules.elasticity) * dot * nx;
                    p.vy -= (1 + spaceRules.elasticity) * dot * ny;
                }
                 // Simple push out, not perfect but effective
                p.x -= nx * p.size;
                p.y -= ny * p.size;
            }
        }
        //endregion
        
        //region --- UI and Control Setup ---
        function buildControls() {
            // Universe Settings
            gameSettingsPanel.innerHTML = `
                <div class="space-y-6">
                     <div>
                        <button id="return-to-title-btn" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition duration-300 special-elite text-lg">Return to Title Screen</button>
                    </div>
                    <div class="border-t border-gray-700 pt-4 mt-6">
                        <label class="block mb-2 font-bold special-elite">Entity Types</label>
                        <div id="particleTypeCountGroup" class="config-button-group">
                            ${[2,3,4,5,6,7,8,9,10,11,12].map(n => `<button class="config-button ${n === 4 ? 'active' : ''}" data-value="${n}">${n}</button>`).join('')}
                        </div>
                    </div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Containment Geometry</label>
                        <div id="dimensionGroup" class="config-button-group">
                            <button class="config-button active" data-shape="vertical" title="A tall, narrow space ideal for observing gravitational effects.">The Monolith (Vertical)</button>
                            <button class="config-button" data-shape="horizontal" title="A wide, panoramic space, excellent for chaotic, expansive interactions.">The Horizon (Horizontal)</button>
                            <button class="config-button" data-shape="square" title="A balanced, stable containment field with no directional bias.">The MandÄla (Square)</button>
                            <button class="config-button" data-shape="circle" title="A focused space with no corners, concentrating all interactions toward the center.">The Sphere (Circle)</button>
                            <button class="config-button" data-shape="ouroboros" title="A circular space with a solid core, forcing ring-like formations.">The Ouroboros</button>
                            <button class="config-button" data-shape="torus" title="A paradoxical space that wraps around on itself. No walls, only the endless loop.">The Aetheric Torus</button>
                            <button class="config-button" data-shape="pillar" title="A solid, impassable object at the center that entities must navigate around.">The Central Anomaly</button>
                            <button class="config-button" data-shape="triangle" title="A triangular space creating unique reflection patterns.">The Trine (Triangle)</button>
                            <button class="config-button" data-shape="lemniscate" title="An infinite loop boundary, guiding particles in a figure-eight pattern.">The Lemniscate (Infinity)</button>
                        </div>
                    </div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Map Size</label>
                        <div id="mapSizeGroup" class="config-button-group">
                            <button class="config-button" data-value="vsmall">Very Small</button>
                            <button class="config-button" data-value="small">Small</button>
                            <button class="config-button active" data-value="medium">Medium</button>
                            <button class="config-button" data-value="large">Large</button>
                            <button class="config-button" data-value="vlarge">Very Large</button>
                        </div>
                    </div>
                    <div>
                        <label for="particleLimitRange" class="block mb-2 font-bold special-elite">Particle Limit: <span id="particleLimitLabel">500</span></label>
                        <input type="range" id="particleLimitRange" min="100" max="2000" value="500" step="100" class="w-full">
                    </div>
                    <div class="border-t border-gray-700 pt-4 mt-6">
                        <label class="block mb-2 font-bold special-elite">Anomaly Frequency</label>
                         <p class="text-sm text-gray-400 mb-3">Chance for a standard physical anomaly to occur on a new sÃ©ance. (Special anomalies have their own separate, very low chance.)</p>
                        <div id="anomalyFrequencyGroup" class="config-button-group">
                            <button class="config-button" data-value="0">No Anomalies</button>
                            <button class="config-button active" data-value="0.02">Rare (2%)</button>
                            <button class="config-button" data-value="0.05">Uncommon (5%)</button>
                            <button class="config-button" data-value="0.15">Common (15%)</button>
                        </div>
                    </div>
                    <div class="border-t border-gray-700 pt-4 mt-6">
                        <label class="block mb-2 font-bold special-elite">Automatic New SÃ©ance</label>
                        <p class="text-sm text-gray-400 mb-3">Automatically start a new sÃ©ance if the particle count falls below a certain percentage of the limit.</p>
                        <div id="autoResetGroup" class="config-button-group">
                            <button class="config-button active" data-value="0">Disabled</button>
                            <button class="config-button" data-value="0.05">5%</button>
                            <button class="config-button" data-value="0.20">20%</button>
                        </div>
                    </div>
                    <div id="anomaly-display-container" class="border-t border-gray-700 pt-4 mt-6">
                        <!-- Anomaly display will be injected here -->
                    </div>
                    <div class="border-t border-gray-700 pt-4 mt-6">
                        <label class="block mb-3 font-bold special-elite">Core Rules</label>
                        <div id="fundamentalBehaviorToggles" class="space-y-3">
                            <div class="flex items-center justify-between">
                                <label for="toggle-mutate" class="cursor-pointer">Enable Mutate</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle-mutate" data-behavior="mutate" ${fundamentalSettings.allowMutate ? 'checked' : ''}>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="toggle-drain" class="cursor-pointer">Enable Drain</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle-drain" data-behavior="drain" ${fundamentalSettings.allowDrain ? 'checked' : ''}>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="toggle-lifespan" class="cursor-pointer">Enable Long Lifespan</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle-lifespan" data-behavior="lifespan" ${fundamentalSettings.longLifespan ? 'checked' : ''}>
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="border-t border-gray-700 pt-4 mt-6">
                        <label class="block mb-3 font-bold special-elite">Inherent Laws (for New SÃ©ances)</label>
                        <div id="inherentLawToggles" class="space-y-3">
                            <div class="flex items-center justify-between">
                                <label for="toggle-law-predation" class="cursor-pointer">Predation</label>
                                <label class="toggle-switch"><input type="checkbox" id="toggle-law-predation" data-law="predation" ${inherentLawSettings.predation ? 'checked' : ''}><span class="slider"></span></label>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="toggle-law-criticalMass" class="cursor-pointer">Critical Mass</label>
                                <label class="toggle-switch"><input type="checkbox" id="toggle-law-criticalMass" data-law="criticalMass" ${inherentLawSettings.criticalMass ? 'checked' : ''}><span class="slider"></span></label>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="toggle-law-createGhosts" class="cursor-pointer">Void Echoes</label>
                                <label class="toggle-switch"><input type="checkbox" id="toggle-law-createGhosts" data-law="createGhosts" ${inherentLawSettings.createGhosts ? 'checked' : ''}><span class="slider"></span></label>
                            </div>
                                <div class="flex items-center justify-between">
                                <label for="toggle-law-inertia" class="cursor-pointer">Inertia</label>
                                <label class="toggle-switch"><input type="checkbox" id="toggle-law-inertia" data-law="inertia" ${inherentLawSettings.inertia ? 'checked' : ''}><span class="slider"></span></label>
                            </div>
                                <div class="flex items-center justify-between">
                                <label for="toggle-law-chainReaction" class="cursor-pointer">Chain Reaction</label>
                                <label class="toggle-switch"><input type="checkbox" id="toggle-law-chainReaction" data-law="chainReaction" ${inherentLawSettings.chainReaction ? 'checked' : ''}><span class="slider"></span></label>
                            </div>
                                <div class="flex items-center justify-between">
                                <label for="toggle-law-thermalShock" class="cursor-pointer">Thermal Shock</label>
                                <label class="toggle-switch"><input type="checkbox" id="toggle-law-thermalShock" data-law="thermalShock" ${inherentLawSettings.thermalShock ? 'checked' : ''}><span class="slider"></span></label>
                            </div>
                        </div>
                    </div>
                </div>`;
            
            // Cosmetic Settings
            cosmeticControls.innerHTML = `
                <div class="space-y-6">
                    <div>
                        <label class="block mb-2 font-bold special-elite">Templates</label>
                        <p class="text-sm text-gray-400 mb-3">Select a preset to quickly change the look and feel. Manually changing a setting below will override the template.</p>
                        <div id="template-group" class="config-button-group grid grid-cols-1 md:grid-cols-2 gap-2">
                                ${Object.entries(templates).map(([id, data]) => `<button class="config-button !text-left !justify-start" data-template-id="${id}" title="${data.description}"><span class="font-bold">${data.name}</span></button>`).join('')}
                        </div>
                    </div>
                    <div class="border-t border-dashed border-gray-600 my-4"></div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Background Color</label>
                        <div id="backgroundColorGroup" class="config-button-group">
                            <button class="config-button" data-color="#0a0a0a">Void</button>
                            <button class="config-button" data-color="#282c34">Ink</button>
                            <button class="config-button" data-color="#333333">Charcoal</button>
                            <button class="config-button" data-color="#1a1a2a">Twilight</button>
                            <button class="config-button" data-color="#020428">Deep Ocean</button>
                            <button class="config-button" data-color="#3a243b">Plum</button>
                            <button class="config-button" data-color="#210228">Royal</button>
                            <button class="config-button" data-color="#3a1010">Crimson</button>
                            <button class="config-button" data-color="#1a2a1a">Verdant</button>
                            <button class="config-button" data-color="#022804">Forest</button>
                            <button class="config-button" data-color="#f0f0f0">Parchment</button>
                            <button class="config-button" data-color="#fdf6e3">Papyrus</button>
                            <button class="config-button" data-color="#3C4E59">War Room Blue</button>
                            <button class="config-button" data-color="#004D40">Terminal Green</button>
                            <button class="config-button" data-color="#FFD700">Atomic Gold</button>
                        </div>
                    </div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Background Style</label>
                        <div id="backgroundStyleGroup" class="config-button-group">
                            ${BACKGROUND_STYLES.map(s => `<button class="config-button" data-bgstyle="${s}">${s.replace(/-/g, ' ').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</button>`).join('')}
                        </div>
                    </div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Particle Style</label>
                        <div id="particleStyleGroup" class="config-button-group">
                            ${PARTICLE_STYLES.map(s => `<button class="config-button" data-style="${s}">${s.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</button>`).join('')}
                        </div>
                    </div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Particle Effect</label>
                        <div id="particleEffectGroup" class="config-button-group">
                            ${PARTICLE_EFFECTS.map(e => `<button class="config-button" data-effect="${e}">${e.charAt(0).toUpperCase() + e.slice(1).replace(/_/g, ' ')}</button>`).join('')}
                        </div>
                    </div>
                    <div>
                        <label class="block mb-2 font-bold special-elite">Color Palette</label>
                        <div id="colorPaletteGroup" class="config-button-group" style="max-height: 200px; overflow-y: auto;">
                            ${Object.entries(COLOR_PALETTES).sort((a, b) => a[1].name.localeCompare(b[1].name)).map(([id, data]) => `<button class="config-button" data-palette="${id}">${data.name}</button>`).join('')}
                        </div>
                    </div>
                    <button id="randomizeCosmeticsButton" class="w-full px-6 py-3 bg-gray-700 text-white rounded-lg hover:bg-gray-600 transition duration-300 special-elite text-lg">Randomize Visage</button>
                </div>`;

            // Viewer Controls
            viewerControls.innerHTML = `
                <div class="space-y-6">
                    <div>
                        <label class="block mb-2 font-bold special-elite">Global Viewer Mode</label>
                        <p class="text-sm text-gray-400 mb-3">Applies a global rendering style that reinterprets the entire simulation, overriding some cosmetic options for a cohesive look.</p>
                        <div id="viewerModeGroup" class="config-button-group">
                            ${VIEWER_MODES.map(v => `<button class="config-button" data-viewer="${v}">${v.charAt(0).toUpperCase() + v.slice(1).replace(/_/g, ' ')}</button>`).join('')}
                        </div>
                    </div>
                    <div id="viewer-description" class="p-4 bg-gray-900/50 border border-gray-700 rounded-lg text-gray-300 text-sm min-h-[100px]">
                        </div>
                </div>`;
            
            // View Settings
            viewControls.innerHTML = `
                <div class="text-center space-y-4">
                    <div>
                        <p class="special-elite mb-2">Zoom</p>
                        <div class="flex items-center justify-center gap-4">
                            <button id="zoomOutButton" class="w-16 h-16 text-3xl bg-gray-700 rounded-full hover:bg-gray-600 transition">-</button>
                            <span class="text-2xl w-16 text-center" id="zoomLevelLabel">1.0x</span>
                            <button id="zoomInButton" class="w-16 h-16 text-3xl bg-gray-700 rounded-full hover:bg-gray-600 transition">+</button>
                        </div>
                    </div>
                    <div>
                        <button id="resetViewButton" class="config-button w-full mt-2">Reset View</button>
                    </div>
                    <div>
                        <p class="special-elite mb-2">Pan</p>
                        <p class="text-gray-400">Drag on the map to move your view.</p>
                    </div>
                </div>`;

            // Seed Controls
            seedControls.innerHTML = `
                <div class="space-y-4">
                    <input type="text" id="seedInput" placeholder="Paste a universe seed here..." class="w-full p-2 rounded border text-white themed-input">
                    <div class="grid grid-cols-2 gap-4">
                        <button id="loadSeedButton" class="w-full px-4 py-3 bg-blue-800 text-white rounded-lg hover:bg-blue-700 transition duration-300 special-elite text-lg">Load Seed</button>
                        <button id="copySeedButton" class="w-full px-4 py-3 bg-green-800 text-white rounded-lg hover:bg-green-700 transition duration-300 special-elite text-lg">Copy Seed</button>
                    </div>
                </div>`;
            
            // Grimoire Content
            referenceContent.innerHTML = `
                <div class="space-y-8 text-gray-300 text-sm">
                    <div class="reference-section">
                        <h3 class="text-xl text-teal-300 special-elite mb-2">Core Concepts</h3>
                        <dl class="space-y-4">
                            <div><dt>Particles</dt><dd>The fundamental constituents of the universe. Each has a unique type, size, charge, temperature, aether, and resonance.</dd></div>
                            <div><dt>Universe Seed</dt><dd>A code defining all initial conditions. Copy the seed to save a universe, or paste a seed to recreate it.</dd></div>
                            <div><dt>Aether</dt><dd>A fundamental energy. High aether provides buoyancy against gravity and can increase stability. It can be transferred or siphoned.</dd></div>
                            <div><dt>Resonance</dt><dd>An intrinsic frequency (0 to 1). Similar resonances can attract, while clashing ones can repel or shatter if the right Anomalies are active.</dd></div>
                            <div><dt>Temperature & State</dt><dd>Particles can be a **Gas** (hot, low density), **Liquid** (moderate), or **Solid** (cold, high density). State affects viscosity and behavior.</dd></div>
                            <div><dt>Ghosts</dt><dd>When the 'Echoes of the Void' Anomaly is active, dying particles may leave behind a temporary, ethereal echo that is immune to most interactions.</dd></div>
                        </dl>
                    </div>
                     <div class="reference-section">
                        <h3 class="text-xl text-teal-300 special-elite mb-2">Special Anomalies</h3>
                        <p class="text-gray-400 mb-4">Extremely rare (0.1% chance) events that are independent of the standard anomaly frequency. They fundamentally alter a new universe.</p>
                        <dl class="space-y-4">
                            <div><dt>Strange Attractor</dt><dd>Spawns a single, super-massive particle that powerfully attracts all other matter.</dd></div>
                            <div><dt>Strange Repulsor</dt><dd>Spawns a single particle that powerfully repels all other matter.</dd></div>
                            <div><dt>Odd Particle</dt><dd>Spawns a single, stationary particle. Anything that touches it becomes a frozen, infectious clone of itself.</dd></div>
                        </dl>
                    </div>
                    <div class="reference-section">
                        <h3 class="text-xl text-teal-300 special-elite mb-2">Inherent Behaviors</h3>
                        <p class="text-gray-400 mb-4">These are potential behaviors randomly assigned between any two particle types at the start of a universe.</p>
                            <dl class="space-y-4">
                            <div><dt>Attract / Repel</dt><dd>The most basic law. Particles will be drawn towards or pushed away from each other over a distance.</dd></div>
                            <div><dt>Merge</dt><dd>Upon contact, two particles combine into a single, larger one, averaging their properties.</dd></div>
                            <div><dt>Mutate</dt><dd>Upon contact, one particle may spontaneously transform into a different type.</dd></div>
                            <div><dt>Shatter</dt><dd>Upon contact, one particle violently breaks apart into smaller fragments.</dd></div>
                            <div><dt>Drain</dt><dd>Upon contact, one particle siphons size from another.</dd></div>
                            <div><dt>Aether Siphon</dt><dd>Upon contact, one particle siphons aether from another.</dd></div>
                            <div><dt>Heat & Charge Transfer</dt><dd>Upon contact, particles may average their temperatures or electrical charges.</dd></div>
                        </dl>
                    </div>
                    <div class="reference-section">
                        <h3 class="text-xl text-teal-300 special-elite mb-2">Potential Anomalies</h3>
                        <p class="text-gray-400 mb-4">Anomalies are random events that alter the physical laws of a new simulation. The chance of one occurring is set in the Universe tab.</p>
                        <dl class="space-y-4">
                            <div><dt>Universal Gravity</dt><dd>A constant pull draws all things in a random direction.</dd></div>
                            <div><dt>Thick Aether</dt><dd>Increases viscosity, causing all motion to be resisted and dampened.</dd></div>
                            <div><dt>Illusory Walls</dt><dd>Changes boundary behavior from bouncing to wrapping around the edges of the universe.</dd></div>
                            <div><dt>Whirlpool</dt><dd>Creates a vortex, pulling all particles in a spiral towards the center.</dd></div>
                            <div><dt>Charged Atmosphere</dt><dd>The void itself carries a charge, pushing or pulling on charged particles.</dd></div>
                            <div><dt>Chaotic Energy</dt><dd>Causes all particles to jitter randomly (Brownian motion).</dd></div>
                            <div><dt>Predation</dt><dd>Enables predation, where larger particles consume smaller ones on contact.</dd></div>
                            <div><dt>Critical Mass</dt><dd>If a particle grows too large, it violently shatters.</dd></div>
                            <div><dt>Cascading Destruction</dt><dd>Makes critical mass explosions potentially trigger other nearby unstable particles.</dd></div>
                            <div><dt>Conservation</dt><dd>Stops the natural, age-based decay of particles. They can only be destroyed by interactions.</dd></div>
                            <div><dt>Void Echoes</dt><dd>Causes dying particles to leave behind a repellant ghost.</dd></div>
                            <div><dt>Inertia</dt><dd>Mass resists all external forces, making heavier particles harder to move.</dd></div>
                            <div><dt>Spontaneous Apparition</dt><dd>The void itself will slowly birth new particles into being.</dd></div>
                            <div><dt>Thermal Shock</dt><dd>Makes particles vulnerable to shattering if their temperature changes too rapidly.</dd></div>
                            <div><dt>Absolute Zero / Supernova</dt><dd>Drastically lowers or raises the ambient temperature of the universe.</dd></div>
                            <div><dt>Resonant Harmony</dt><dd>Unlocks a powerful attractive force between particles with similar resonance frequencies.</dd></div>
                            <div><dt>Dissonant Feedback</dt><dd>Causes particles with clashing resonances to shatter the weaker one upon collision.</dd></div>
                            <div><dt>Aetheric Tide / Entropic Field</dt><dd>Drastically raises the ambient aether level, or causes it to slowly bleed from all particles.</dd></div>
                        </dl>
                    </div>
                </div>`;
            
            buildBrushControls();
        }

        function setupCosmeticControls() {
            // Setup Template buttons first
            updateActiveButton(cosmeticControls.querySelector('#template-group'), activeTemplateId, 'templateId');

            // Then update individual cosmetic buttons based on the current state
            updateActiveButton(cosmeticControls.querySelector('#particleStyleGroup'), cosmeticRules.particleStyle, 'style');
            updateActiveButton(cosmeticControls.querySelector('#particleEffectGroup'), cosmeticRules.particleEffect, 'effect');
            updateActiveButton(cosmeticControls.querySelector('#backgroundStyleGroup'), cosmeticRules.backgroundStyle || 'solid', 'bgstyle');
            updateActiveButton(cosmeticControls.querySelector('#colorPaletteGroup'), cosmeticRules.colorPalette, 'palette');
            updateActiveButton(cosmeticControls.querySelector('#backgroundColorGroup'), backgroundSettings.color, 'color');
            updateActiveButton(viewerControls.querySelector('#viewerModeGroup'), cosmeticRules.viewerMode || 'none', 'viewer');
            updateActiveButton(gameSettingsPanel.querySelector('#dimensionGroup'), cosmeticRules.containmentGeometry || 'vertical', 'shape');
            updateViewerDescription();
            
            const crtOverlay = document.getElementById('crt-overlay');
            crtOverlay.classList.toggle('hidden', cosmeticRules.backgroundStyle !== 'crt_glow');
        }

        function generateCosmetics() {
            document.body.style.backgroundColor = `hsl(${cosmeticRules.backgroundHue}, 15%, 7%)`;
            stars = [];
        }
        
        // REVISED: This function now just displays the current anomaly.
        function setupAnomalyDisplay() {
            const anomaliesContainer = document.getElementById('anomaly-display-container');
            if (!anomaliesContainer) return;
            anomaliesContainer.innerHTML = '';
            if (activeAnomaly) {
                anomaliesContainer.innerHTML = `
                    <h3 class="text-xl special-elite text-teal-300">Active Anomaly</h3>
                    <div class="p-4 bg-gray-900/50 border border-gray-700 rounded-lg">
                        <h4 class="text-lg font-bold text-yellow-300 special-elite">${activeAnomaly.name}</h4>
                        <p class="text-gray-300">${ANOMALY_DESCRIPTIONS[activeAnomaly.id]}</p>
                    </div>
                `;
            } else {
                anomaliesContainer.innerHTML = `
                    <h3 class="text-xl special-elite text-teal-300">Active Anomaly</h3>
                    <p class="text-gray-400">The laws of this universe are stable. Increase the frequency above for a higher chance of an anomaly on the next sÃ©ance.</p>
                `;
            }
        }
        //endregion

        //region --- Event Listeners and UI Handlers ---
        function addAllEventListeners() {
            // Main Actions
            newGameButton.addEventListener('click', () => {
                setup();
                settingsPanel.classList.remove('active');
            });
            
            replayButton.addEventListener('click', () => {
                setup(null, true); // Pass true for isReplay
                settingsPanel.classList.remove('active');
            });

            pauseButton.addEventListener('click', togglePause);
            
            brushShortcutBtn.addEventListener('click', toggleBrushEnabled);
            randomizeVisageShortcutBtn.addEventListener('click', randomizeAllCosmetics);
            
            // Anomaly Modal Dismissal
            anomalyModal.addEventListener('click', () => {
                anomalyModal.classList.add('hidden');
            });

            // Panel Toggles
            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.toggle('active');
            });
            
            // Panel Close Buttons
            document.querySelectorAll('.close-panel-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.closest('.panel').classList.remove('active');
                });
            });

            // Settings Tabs
            settingsTabs.addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-button')) {
                    const tabId = e.target.dataset.tab;
                    settingsTabs.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                    
                    document.querySelectorAll('.tab-content').forEach(tab => {
                        tab.classList.toggle('active', tab.id === tabId);
                    });
                }
            });

            // Universe Config
            gameSettingsPanel.addEventListener('click', (e) => {
                if (e.target.id === 'return-to-title-btn') {
                    const titleOverlay = document.getElementById('title-screen-overlay');
                    titleOverlay.classList.remove('hidden');
                    if (!isPaused) {
                        togglePause();
                    }
                    settingsPanel.classList.remove('active');
                    return;
                }
                const buttonGroup = e.target.closest('.config-button-group');
                if (buttonGroup && e.target.classList.contains('config-button')) {
                    const dataKey = Object.keys(e.target.dataset)[0]; // e.g., 'value', 'shape'
                    const value = e.target.dataset[dataKey];
                    updateActiveButton(buttonGroup, value, dataKey);
                    
                    if (buttonGroup.id === 'dimensionGroup') {
                        const shape = e.target.dataset.shape; 
                        cosmeticRules.containmentGeometry = shape; 
                        handleGeometryAnomalyInteraction(shape);
                    }
                    if (buttonGroup.id === 'anomalyFrequencyGroup') {
                        anomalySettings.frequency = parseFloat(value);
                        saveAnomalySettings();
                    }
                    if (buttonGroup.id === 'autoResetGroup') {
                        autoResetSettings.threshold = parseFloat(value);
                        saveAutoResetSettings();
                    }
                }
            });
            gameSettingsPanel.addEventListener('input', (e) => {
                if (e.target.id === 'particleLimitRange') {
                    gameSettingsPanel.querySelector('#particleLimitLabel').textContent = e.target.value;
                }
            });
            gameSettingsPanel.addEventListener('change', (e) => {
                const toggle = e.target.closest('.toggle-switch input');
                if (toggle) {
                    if (toggle.dataset.behavior) {
                        const behavior = toggle.dataset.behavior;
                        if (behavior === 'mutate') fundamentalSettings.allowMutate = toggle.checked;
                        else if (behavior === 'drain') fundamentalSettings.allowDrain = toggle.checked;
                        else if (behavior === 'lifespan') fundamentalSettings.longLifespan = toggle.checked;
                        saveFundamentalSettings();
                    } else if (toggle.dataset.law) {
                        const law = toggle.dataset.law;
                        inherentLawSettings[law] = toggle.checked;
                        saveInherentLawSettings();
                    }
                }
            });

           // Cosmetic Config
            cosmeticControls.addEventListener('click', (e) => {
                if (e.target.id === 'randomizeCosmeticsButton') {
                    randomizeAllCosmetics();
                    return;
                }
                
                // Find the actual button that was clicked, not just the specific target (like a span).
                const button = e.target.closest('.config-button');
                
                // If the click wasn't on a config button or its child, do nothing.
                if (!button) return;
                
                const buttonGroup = button.closest('.config-button-group');
                if (!buttonGroup) return;

                // If a template button was clicked, apply it and stop.
                if (buttonGroup.id === 'template-group') {
                    applyTemplate(button.dataset.templateId);
                    return;
                }

                // If any other config button was clicked, it's a manual override.
                // Deselect the active template to show the state is now "custom".
                if (activeTemplateId) {
                    activeTemplateId = null;
                    saveActiveTemplate();
                    updateActiveButton(cosmeticControls.querySelector('#template-group'), null, 'templateId');
                }

                // Apply the specific manual override.
                const { style, effect, bgstyle, palette, color } = button.dataset;

                if (style !== undefined) {
                    cosmeticRules.particleStyle = style;
                    updateActiveButton(buttonGroup, style, 'style');
                }
                if (effect !== undefined) {
                    cosmeticRules.particleEffect = effect;
                    updateActiveButton(buttonGroup, effect, 'effect');
                }
                if (bgstyle !== undefined) {
                    cosmeticRules.backgroundStyle = bgstyle;
                    updateActiveButton(buttonGroup, bgstyle, 'bgstyle');
                    const crtOverlay = document.getElementById('crt-overlay');
                    crtOverlay.classList.toggle('hidden', bgstyle !== 'crt_glow');
                }
                if (palette !== undefined) {
                    cosmeticRules.colorPalette = palette;
                    applyCurrentPalette();
                    updateActiveButton(buttonGroup, palette, 'palette');
                }
                if (color !== undefined) {
                    backgroundSettings.color = color;
                    updateActiveButton(buttonGroup, color, 'color');
                    saveBackgroundSettings();
                }
            });
            cosmeticControls.addEventListener('change', (e) => {
                const id = e.target.id;
            });

            // Viewer Controls Listener
            viewerControls.addEventListener('click', (e) => {
                const buttonGroup = e.target.closest('.config-button-group');
                if (buttonGroup && e.target.classList.contains('config-button')) {
                    const viewerMode = e.target.dataset.viewer;
                    if (viewerMode !== undefined) {
                        cosmeticRules.viewerMode = viewerMode;
                        updateActiveButton(buttonGroup, viewerMode, 'viewer');
                        updateViewerDescription();
                    }
                }
            });

            // Seed Controls
            seedControls.addEventListener('click', (e) => {
                if (e.target.id === 'loadSeedButton') {
                    const seed = seedControls.querySelector('#seedInput').value.trim();
                    if (seed) {
                        settingsPanel.classList.remove('active');
                        setup(seed);
                    }
                }
                if (e.target.id === 'copySeedButton') {
                    const seed = generateSeed();
                    navigator.clipboard.writeText(seed).then(() => {
                        e.target.textContent = 'Copied!';
                        setTimeout(() => e.target.textContent = 'Copy Seed', 2000);
                    });
                }
            });

            // View Controls
            viewControls.addEventListener('click', (e) => {
                if(e.target.id === 'zoomInButton') applyZoom(1.2);
                if(e.target.id === 'zoomOutButton') applyZoom(1 / 1.2);
                if(e.target.id === 'resetViewButton') frameCanvasView();
            });

            // Canvas Panning, Brushing, and UI Toggle
            canvas.addEventListener('mousedown', (e) => handleInteractionStart(e.clientX, e.clientY));
            canvas.addEventListener('mousemove', (e) => handleInteractionMove(e.clientX, e.clientY));
            canvas.addEventListener('mouseup', handleInteractionEnd);
            canvas.addEventListener('mouseleave', handleInteractionEnd);
            canvas.addEventListener('touchstart', (e) => { 
                e.preventDefault();
                if (e.touches.length > 0) {
                    handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });
            canvas.addEventListener('touchmove', (e) => { 
                e.preventDefault();
                if (e.touches.length > 0) {
                    handleInteractionMove(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });
            canvas.addEventListener('touchend', handleInteractionEnd);
            canvas.addEventListener('touchcancel', handleInteractionEnd);
            
            window.addEventListener('resize', () => resizeCanvas(false));
            
            // --- Audio Visualizer Event Listeners ---
            const audioToggle = document.getElementById('audio-visualizer-toggle');
            const audioOptions = document.getElementById('audio-options-container');

            audioToggle.addEventListener('change', (e) => {
                audioOptions.classList.toggle('hidden', !e.target.checked);
                if (e.target.checked) {
                    initAudioVisualizer();
                } else {
                    stopAudioVisualizer();
                }
            });

            document.getElementById('audio-mode-group').addEventListener('click', (e) => {
                if (e.target.classList.contains('config-button')) {
                    audioVisualizerState.mode = e.target.dataset.mode;
                    updateActiveButton(e.target.parentElement, audioVisualizerState.mode, 'mode');
                    // Reset rules when switching modes to avoid lingering effects
                    stopAudioVisualizer(); // This safely resets rules
                    if (audioToggle.checked) initAudioVisualizer(); // And re-enables if it was on
                }
            });
            
            const audioReactivitySlider = document.getElementById('audio-reactivity-slider');
            const audioReactivityLabel = document.getElementById('audio-reactivity-label');
            audioReactivitySlider.addEventListener('input', (e) => {
                const reactivity = parseFloat(e.target.value);
                audioVisualizerState.reactivity = reactivity;
                audioReactivityLabel.textContent = `${reactivity.toFixed(1)}x`;
            });
            audioReactivitySlider.addEventListener('change', saveAudioSettings);
        }
        
        function toggleUI() {
            const isVisible = !mainControls.classList.contains('hidden');
            if (isVisible) {
                mainControls.classList.add('hidden');
                brushToolbar.classList.add('hidden');
                appContainer.classList.add('controls-hidden'); // Hide padding
            } else {
                mainControls.classList.remove('hidden');
                if (brushSettings.enabled) {
                    brushToolbar.classList.remove('hidden');
                }
                appContainer.classList.remove('controls-hidden'); // Restore padding
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            pauseIcon.classList.toggle('hidden', isPaused);
            playIcon.classList.toggle('hidden', !isPaused);
        }
        
        function toggleBrushEnabled() {
            brushSettings.enabled = !brushSettings.enabled;
            
            // Update the main toggle in the settings panel
            const brushEnableToggle = document.getElementById('brush-enabled-toggle');
            if (brushEnableToggle) {
                brushEnableToggle.checked = brushSettings.enabled;
            }
            
            // Update the brush options container visibility
            const brushOptionsContainer = document.getElementById('brush-options-container');
            if (brushOptionsContainer) {
                brushOptionsContainer.classList.toggle('hidden', !brushSettings.enabled);
            }
            
            // Update canvas cursor and shortcut button appearance
            canvas.classList.toggle('brush-active', brushSettings.enabled);
            brushShortcutBtn.classList.toggle('active', brushSettings.enabled);
            brushToolbar.classList.toggle('hidden', !brushSettings.enabled || mainControls.classList.contains('hidden'));

            saveBrushSettings();
        }

        function randomizeAllCosmetics() {
            // Randomize Background Color
            const bgButtons = cosmeticControls.querySelectorAll('#backgroundColorGroup .config-button');
            const randomBgButton = bgButtons[Math.floor(Math.random() * bgButtons.length)];
            backgroundSettings.color = randomBgButton.dataset.color;
            
            // Randomize Styles and Effects
            cosmeticRules.backgroundStyle = BACKGROUND_STYLES[Math.floor(Math.random() * BACKGROUND_STYLES.length)];
            cosmeticRules.particleStyle = PARTICLE_STYLES.filter(s => s !== 'random')[Math.floor(Math.random() * (PARTICLE_STYLES.length - 1))];
            cosmeticRules.particleEffect = PARTICLE_EFFECTS[Math.floor(Math.random() * PARTICLE_EFFECTS.length)];
            
            // Randomize Palette
            const paletteKeys = Object.keys(COLOR_PALETTES);
            cosmeticRules.colorPalette = paletteKeys[Math.floor(Math.random() * paletteKeys.length)];

            // Deselect active template
            activeTemplateId = null;
            saveActiveTemplate();

            // Apply and update UI
            setupCosmeticControls(); // Update UI toggles and buttons
            saveBackgroundSettings();
            applyCurrentPalette();
            generateCosmetics();
        }

        function applyCurrentPalette() {
            if (particleTypes.length === 0) return;
            const newTypes = generateParticleTypes(particleTypes.length, cosmeticRules.colorPalette);
            const typeMap = {};
            newTypes.forEach(t => { typeMap[t.id] = t; });

            particleTypes.forEach(oldType => {
                if (typeMap[oldType.id]) {
                    oldType.color = typeMap[oldType.id].color;
                    if (typeMap[oldType.id].hue !== undefined) {
                        oldType.hue = typeMap[oldType.id].hue;
                    }
                }
            });

            particles.forEach(p => {
                const newTypeData = particleTypes.find(pt => pt.id === p.typeId);
                if (newTypeData) {
                    p.color = newTypeData.color;
                    p.type = newTypeData;
                }
            });
            updateBrushUI(); // Update swatch colors
        }
        
        function generateSeed() {
            const seedData = {
                particleTypes: initialConditions.particleTypes,
                interactionRules: initialConditions.interactionRules,
                cosmeticRules: initialConditions.cosmeticRules,
                settings: {
                    particleTypeCount: gameSettingsPanel.querySelector('#particleTypeCountGroup .config-button.active').dataset.value,
                    mapSize: gameSettingsPanel.querySelector('#mapSizeGroup .config-button.active').dataset.value,
                    maxParticles: maxParticles,
                },
                activeAnomaly: initialConditions.activeAnomaly,
                specialAnomalyId: initialConditions.specialAnomalyId // Save special anomaly
            };
            return btoa(JSON.stringify(seedData));
        }

        function loadFromSeed(seedString) {
            try {
                const decoded = atob(seedString);
                const seedData = JSON.parse(decoded);
                initialConditions = seedData;

                // Deselect any active template since we're loading specific settings
                activeTemplateId = null;
                saveActiveTemplate();

                if (seedData.settings) {
                    updateActiveButton(gameSettingsPanel.querySelector('#particleTypeCountGroup'), seedData.settings.particleTypeCount || '4', 'value');
                    updateActiveButton(gameSettingsPanel.querySelector('#mapSizeGroup'), seedData.settings.mapSize || 'medium', 'value');
                    gameSettingsPanel.querySelector('#particleLimitRange').value = seedData.settings.maxParticles || 1000;
                    gameSettingsPanel.querySelector('#particleLimitLabel').textContent = seedData.settings.maxParticles || 1000;
                }
                if (seedData.cosmeticRules && seedData.cosmeticRules.containmentGeometry) {
                    updateActiveButton(gameSettingsPanel.querySelector('#dimensionGroup'), seedData.cosmeticRules.containmentGeometry, 'shape');
                }
            } catch (e) {
                console.error("Invalid seed string:", e);
                initialConditions = {};
            }
        }

        function updateActiveButton(group, value, dataKey) {
            if (!group) return;
            Array.from(group.children).forEach(button => {
                button.classList.toggle('active', button.dataset[dataKey] === value);
            });
        }

        function resizeCanvas(shouldResetView = true) {
            const container = document.getElementById('simulationContainer');
            const { clientWidth, clientHeight } = container;
            canvas.width = clientWidth;
            canvas.height = clientHeight;

            offscreenCanvas.width = clientWidth;
            offscreenCanvas.height = clientHeight;

            if (shouldResetView) {
                frameCanvasView();
            }
        }

        function frameCanvasView() {
            const viewWidth = canvas.width;
            const viewHeight = canvas.height;

            if (worldWidth <= 0 || worldHeight <= 0) return;

            if (viewWidth > 0 && viewHeight > 0) {
                const zoomX = viewWidth / worldWidth;
                const zoomY = viewHeight / worldHeight;
                const scale = Math.min(zoomX, zoomY) * 0.95; // Add a little padding

                const panX = (viewWidth - (worldWidth * scale)) / 2;
                const panY = (viewHeight - (worldHeight * scale)) / 2;
                
                viewTransform = new DOMMatrix([scale, 0, 0, scale, panX, panY]);
            }
            updateZoomLabel();
        }

        function updateZoomLabel() {
            const label = viewControls.querySelector('#zoomLevelLabel');
            if(label) label.textContent = `${viewTransform.a.toFixed(1)}x`;
        }

        function applyZoom(factor) {
            const currentScale = viewTransform.a;
            const newScale = Math.max(0.2, Math.min(5, currentScale * factor));
            const scaleChange = newScale / currentScale;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            viewTransform.preMultiplySelf(new DOMMatrix().translate(centerX, centerY).scale(scaleChange).translate(-centerX, -centerY));
            updateZoomLabel();
        }
        //endregion

        //region --- Persisted Settings Functions ---
        function saveFundamentalSettings() {
            try {
                localStorage.setItem('fundamentalSettings', JSON.stringify(fundamentalSettings));
            } catch (e) {
                console.error("Could not save fundamental settings to localStorage:", e);
            }
        }

        function loadFundamentalSettings() {
            try {
                const saved = localStorage.getItem('fundamentalSettings');
                if (saved) {
                    const loadedSettings = JSON.parse(saved);
                    fundamentalSettings = { ...{ allowMutate: false, allowDrain: false, longLifespan: false }, ...loadedSettings };
                }
            } catch (e) {
                console.error("Could not load fundamental settings from localStorage:", e);
            }
        }
        
        function saveInherentLawSettings() {
            try {
                localStorage.setItem('inherentLawSettings', JSON.stringify(inherentLawSettings));
            } catch (e) {
                console.error("Could not save inherent law settings to localStorage:", e);
            }
        }

        function loadInherentLawSettings() {
            try {
                const saved = localStorage.getItem('inherentLawSettings');
                if (saved) {
                    const loadedSettings = JSON.parse(saved);
                    inherentLawSettings = { ...{ predation: false, criticalMass: false, createGhosts: false, inertia: false, chainReaction: false, thermalShock: false }, ...loadedSettings };
                }
            } catch (e) {
                console.error("Could not load inherent law settings from localStorage:", e);
            }
        }

        function saveAnomalySettings() {
            try {
                localStorage.setItem('anomalySettings', JSON.stringify(anomalySettings));
            } catch (e) {
                console.error("Could not save anomaly settings to localStorage:", e);
            }
        }

        function loadAnomalySettings() {
            try {
                const saved = localStorage.getItem('anomalySettings');
                if (saved) {
                    const loadedSettings = JSON.parse(saved);
                    anomalySettings = { ...{ frequency: 0.02 }, ...loadedSettings };
                }
            } catch (e) {
                console.error("Could not load anomaly settings from localStorage:", e);
            }
        }

        function saveBackgroundSettings() {
            try {
                localStorage.setItem('backgroundSettings', JSON.stringify(backgroundSettings));
            } catch (e) {
                console.error("Could not save background settings to localStorage:", e);
            }
        }

        function loadBackgroundSettings() {
            try {
                const saved = localStorage.getItem('backgroundSettings');
                if (saved) {
                    const loadedSettings = JSON.parse(saved);
                    backgroundSettings = { ...{ color: '#0a0a0a' }, ...loadedSettings };
                }
            } catch (e) {
                console.error("Could not load background settings from localStorage:", e);
            }
        }
        
        function saveAutoResetSettings() {
            try {
                localStorage.setItem('autoResetSettings', JSON.stringify(autoResetSettings));
            } catch (e) { console.error("Could not save auto-reset settings", e); }
        }
        
        function loadAutoResetSettings() {
            try {
                const saved = localStorage.getItem('autoResetSettings');
                if (saved) {
                    autoResetSettings = { ...{ threshold: 0 }, ...JSON.parse(saved) };
                }
            } catch (e) { console.error("Could not load auto-reset settings", e); }
        }

        function saveAudioSettings() {
            try {
                const settingsToSave = {
                    reactivity: audioVisualizerState.reactivity
                };
                localStorage.setItem('audioSettings', JSON.stringify(settingsToSave));
            } catch (e) { console.error("Could not save audio settings", e); }
        }

        function loadAudioSettings() {
            try {
                const saved = localStorage.getItem('audioSettings');
                if (saved) {
                    const loaded = JSON.parse(saved);
                    audioVisualizerState.reactivity = loaded.reactivity || 1.0;
                }
            } catch (e) { console.error("Could not load audio settings", e); }
        }
        //endregion
        
        //region --- DRAWING HELPERS ---
        function drawBackground() {
            switch(cosmeticRules.backgroundStyle) {
                case 'gradient':
                    const gradient = ctx.createRadialGradient(worldWidth/2, worldHeight/2, 0, worldWidth/2, worldHeight/2, Math.max(worldWidth, worldHeight));
                    gradient.addColorStop(0, `hsla(${cosmeticRules.backgroundHue}, 20%, 15%, 0.5)`);
                    gradient.addColorStop(1, `hsla(${cosmeticRules.backgroundHue}, 15%, 7%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, worldWidth, worldHeight);
                    break;
                case 'grid':
                    ctx.strokeStyle = `hsla(${cosmeticRules.backgroundHue}, 20%, 20%, 0.5)`;
                    ctx.lineWidth = 1 / viewTransform.a;
                    for (let x = 0; x <= worldWidth; x += 50) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke();
                    }
                    for (let y = 0; y <= worldHeight; y += 50) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke();
                    }
                    break;
                case 'rings':
                    ctx.strokeStyle = `hsla(${cosmeticRules.backgroundHue}, 20%, 50%, 0.3)`;
                    ctx.lineWidth = 2 / viewTransform.a;
                    for (let i = 1; i < 20; i++) {
                        ctx.beginPath(); ctx.arc(worldWidth / 2, worldHeight / 2, i * 100, 0, Math.PI * 2); ctx.stroke();
                    }
                    break;
                case 'parallax-grid':
                    const parallaxLayers = [
                        { speed: 0.2, size: 150, hue: cosmeticRules.parallaxHue - 20, alpha: 0.1 },
                        { speed: 0.4, size: 100, hue: cosmeticRules.parallaxHue, alpha: 0.2 },
                        { speed: 0.6, size: 50, hue: cosmeticRules.parallaxHue + 20, alpha: 0.3 },
                    ];
                    parallaxLayers.forEach(layer => {
                        ctx.save();
                        const panOffsetX = (viewTransform.e - (canvas.width/2 * (1-viewTransform.a))) * layer.speed;
                        const panOffsetY = (viewTransform.f - (canvas.height/2* (1-viewTransform.a))) * layer.speed;
                        ctx.translate(-panOffsetX, -panOffsetY);

                        ctx.strokeStyle = `hsla(${layer.hue}, 40%, 50%, ${layer.alpha})`;
                        ctx.lineWidth = 1 / viewTransform.a;
                        for (let x = 0; x <= worldWidth + layer.size; x += layer.size) {
                            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke();
                        }
                        for (let y = 0; y <= worldHeight + layer.size; y += layer.size) {
                            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke();
                        }
                        ctx.restore();
                    });
                    break;
                case 'cold-war-board':
                    ctx.strokeStyle = `rgba(80, 200, 120, 0.2)`;
                    ctx.lineWidth = 1 / viewTransform.a;
                    for (let x = 0; x <= worldWidth; x += 40) {
                        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke();
                    }
                    for (let y = 0; y <= worldHeight; y += 40) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke();
                    }
                    break;
                case 'crt_glow':
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.07)';
                    for(let y=0; y < worldHeight; y+=4 / viewTransform.a) {
                        ctx.fillRect(0, y, worldWidth, 1 / viewTransform.a);
                    }
                    break;
                case 'interference_pattern':
                    const bandWidth = 50;
                    const totalParticleMass = particles.reduce((sum, p) => sum + p.mass, 1);
                    const avgX = particles.reduce((sum, p) => sum + p.x * p.mass, 0) / totalParticleMass;
                    for (let x = 0; x < worldWidth; x += bandWidth) {
                        const warpFactor = Math.sin((x - avgX) / 200) * 20;
                        const intensity = (Math.sin(x / bandWidth * Math.PI * 2 + Date.now() * 0.0001) + 1) / 2;
                        ctx.fillStyle = `rgba(200, 220, 255, ${intensity * 0.08})`;
                        ctx.fillRect(x + warpFactor, 0, bandWidth, worldHeight);
                    }
                    break;
            }
        }

        function drawMyceliumNetwork() {
            const MAX_NEIGHBORS = 3;
            const MAX_DIST_SQ = 150 * 150;

            // First, draw all the connecting lines
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                let neighbors = [];
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < MAX_DIST_SQ) {
                        neighbors.push({ particle: p2, distSq: distSq });
                    }
                }

                neighbors.sort((a, b) => a.distSq - b.distSq);
                
                for (let k = 0; k < Math.min(neighbors.length, MAX_NEIGHBORS); k++) {
                    const neighbor = neighbors[k].particle;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(neighbor.x, neighbor.y);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = p1.color;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                }
            }
            // Then, draw all the particles on top of the lines
            particles.forEach(p => drawSingleParticle(p));
        }
        //endregion
        
        //region --- VIEWER MODE DRAWING FUNCTIONS ---

        function drawAetherDensityView() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, worldWidth, worldHeight);

            // Draw a background glow based on average aether
            const avgAether = particles.reduce((sum, p) => sum + p.aether, 0) / (particles.length || 1);
            const bgGradient = ctx.createRadialGradient(worldWidth / 2, worldHeight / 2, 0, worldWidth / 2, worldHeight / 2, worldWidth);
            bgGradient.addColorStop(0, getAetherColor(avgAether, 0.15));
            bgGradient.addColorStop(1, getAetherColor(avgAether, 0));
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0,0,worldWidth, worldHeight);

            particles.forEach(p => {
                ctx.fillStyle = getAetherColor(p.aether, 0.9);
                ctx.shadowColor = getAetherColor(p.aether, 1.0);
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function drawDopplerShiftView() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)'; // Motion blur effect
            ctx.fillRect(0, 0, worldWidth, worldHeight);

            particles.forEach(p => {
                const speed = Math.sqrt(p.vx**2 + p.vy**2);
                ctx.fillStyle = getDopplerColor(speed);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        //endregion
        
        //region --- COLOR HELPER FUNCTIONS ---
        function getAetherColor(aether, alpha) {
            const aetherPercent = Math.max(0, Math.min(1, aether / 150));
            const hue = 180 + (aetherPercent * 120); // Cyan to Magenta
            const lightness = 20 + (aetherPercent * 50);
            return `hsla(${hue}, 90%, ${lightness}%, ${alpha})`;
        }

        function getDopplerColor(speed) {
            // Map speed (0 to ~8) to hue (0 (red) to 260 (violet))
            const speedPercent = Math.min(1, speed / 8);
            const hue = 260 * speedPercent;
            return `hsl(${260 - hue}, 100%, 65%)`;
        }

        function hexToHsl(H) {
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            H = H.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });

            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(H);
            if (!result) {
                return null;
            }

            let r = parseInt(result[1], 16);
            let g = parseInt(result[2], 16);
            let b = parseInt(result[3], 16);

            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max == min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            h = Math.round(h * 360);
            s = Math.round(s * 100);
            l = Math.round(l * 100);
            return [h, s, l];
        }

        function updateViewerDescription() {
            const descEl = document.getElementById('viewer-description');
            if (!descEl) return;
            const descriptions = {
                none: "<strong>Default View</strong><br>Renders the simulation using the standard cosmetic settings chosen in the Visage tab.",
                aether_density: "<strong>Aether Density</strong><br>Visualizes aether levels, from starved (dark) to rich (glowing cyan/magenta).",
                doppler_shift: "<strong>Doppler Shift</strong><br>Colors particles by velocity. Fast particles are blue-shifted, slow particles are red-shifted. A motion blur effect is applied."
            };
            descEl.innerHTML = descriptions[cosmeticRules.viewerMode] || "";
        }
        //endregion

        //region --- BRUSH FUNCTIONALITY ---

        function buildBrushControls() {
            brushTab.innerHTML = `
                <div class="flex items-center justify-between mb-6">
                    <label for="brush-enabled-toggle" class="font-bold special-elite text-xl cursor-pointer">Enable Brush</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="brush-enabled-toggle" ${brushSettings.enabled ? 'checked' : ''}>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div id="brush-options-container" class="${brushSettings.enabled ? '' : 'hidden'}">
                    <div class="mb-6">
                        <label class="block mb-2 font-bold special-elite">Brush Size: <span id="brush-size-label">${brushSettings.size}</span></label>
                        <input type="range" id="brush-size-range" min="5" max="100" value="${brushSettings.size}" step="1" class="w-full">
                    </div>

                    <div class="border-t border-gray-700 pt-4 mb-6">
                        <h4 class="text-lg special-elite text-teal-300 mb-2">Aetheric Brush</h4>
                        <p class="text-sm text-gray-400 mb-3">Creates new particles of the selected type.</p>
                        <div id="aetheric-brush-mode-group" class="config-button-group">
                            <button class="config-button" data-type="aetheric" data-mode="stream">Stream</button>
                            <button class="config-button" data-type="aetheric" data-mode="spray">Spray Can</button>
                            <button class="config-button" data-type="aetheric" data-mode="pulse">Pulse / Nova</button>
                            <button class="config-button" data-type="aetheric" data-mode="calligrapher">Calligrapher</button>
                        </div>
                    </div>

                    <div class="border-t border-gray-700 pt-4">
                        <h4 class="text-lg special-elite text-teal-300 mb-2">Effect Brush</h4>
                        <p class="text-sm text-gray-400 mb-3">Influences existing particles instead of creating new ones.</p>
                        
                        <div class="p-3 bg-gray-900/50 rounded-lg mb-3">
                            <label class="font-bold">Velocity Painter</label>
                            <p class="text-xs text-gray-400 mb-2">"Paints" velocity onto particles.</p>
                            <button class="config-button w-full" data-type="effect" data-mode="velocity">Activate</button>
                        </div>
                        <div class="p-3 bg-gray-900/50 rounded-lg mb-3">
                            <label class="font-bold">Type Mutator</label>
                            <p class="text-xs text-gray-400 mb-2">Forces particles to become the selected Aetheric type.</p>
                            <button class="config-button w-full" data-type="effect" data-mode="typeMutator">Activate</button>
                        </div>
                        <div class="p-3 bg-gray-900/50 rounded-lg mb-3">
                            <label class="font-bold">Shrapnel</label>
                            <p class="text-xs text-gray-400 mb-2">Shatters particles on contact.</p>
                            <button class="config-button w-full" data-type="effect" data-mode="shrapnel">Activate</button>
                        </div>
                        <div class="p-3 bg-gray-900/50 rounded-lg mb-3">
                            <label class="font-bold">Eraser</label>
                            <p class="text-xs text-gray-400 mb-2">Deletes particles on contact.</p>
                            <button class="config-button w-full" data-type="effect" data-mode="eraser">Activate</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add listeners for the new controls
            document.getElementById('brush-enabled-toggle').addEventListener('change', (e) => {
                if (brushSettings.enabled !== e.target.checked) {
                    toggleBrushEnabled();
                }
            });

            document.getElementById('brush-size-range').addEventListener('input', (e) => {
                brushSettings.size = parseInt(e.target.value, 10);
                document.getElementById('brush-size-label').textContent = brushSettings.size;
            });
            
            document.getElementById('brush-size-range').addEventListener('change', saveBrushSettings);


            brushTab.addEventListener('click', (e) => {
                if(e.target.matches('.config-button')) {
                    const { type, mode } = e.target.dataset;
                    
                    brushSettings.brushType = type;
                    if(type === 'aetheric') brushSettings.aethericMode = mode;
                    if(type === 'effect') brushSettings.effectMode = mode;

                    updateBrushUI();
                    saveBrushSettings();
                }
            });
            updateBrushUI(); // Set initial active states
        }

        // REVISED: Function to update all brush UI active states
        function updateBrushUI() {
            if (!brushTab.innerHTML) return; 
            if (particleTypes.length > 0 && !particleTypes.find(t => t.id === brushSettings.selectedParticleTypeID)) {
                brushSettings.selectedParticleTypeID = particleTypes[0].id;
            }
            
            // Update Aetheric Brush buttons in settings panel
            const aethericButtons = brushTab.querySelectorAll('[data-type="aetheric"]');
            aethericButtons.forEach(btn => {
                const isActive = brushSettings.brushType === 'aetheric' && brushSettings.aethericMode === btn.dataset.mode;
                btn.classList.toggle('active', isActive);
            });

            // Update Effect Brush buttons in settings panel
            const effectButtons = brushTab.querySelectorAll('[data-type="effect"]');
            effectButtons.forEach(btn => {
                let isActive = brushSettings.brushType === 'effect' && brushSettings.effectMode === btn.dataset.mode;
                btn.classList.toggle('active', isActive);
            });

            updateBrushToolbar();
        }

        // REVISED: More stable toolbar update logic
        function updateBrushToolbar() {
            if (!particleTypes || particleTypes.length === 0) return;
            
            // Update selected particle if it's no longer valid
            if (particleTypes.length > 0 && !particleTypes.find(t => t.id === brushSettings.selectedParticleTypeID)) {
                brushSettings.selectedParticleTypeID = particleTypes[0].id;
            }

            // Update active state of main type buttons
            brushToolbar.querySelector('[data-type="aetheric"]').classList.toggle('active', brushSettings.brushType === 'aetheric');
            brushToolbar.querySelector('[data-type="effect"]').classList.toggle('active', brushSettings.brushType === 'effect');

            const aethericOptions = document.getElementById('aetheric-brush-options');
            if (brushSettings.brushType === 'aetheric' || brushSettings.effectMode === 'typeMutator') {
                const swatchContainer = document.getElementById('particle-swatch-container');
                const swatchesHTML = particleTypes.filter(t => !t.isSpecial).map(type => `
                    <div class="particle-swatch ${type.id === brushSettings.selectedParticleTypeID ? 'active' : ''}" 
                         style="background-color: ${type.color}"
                         data-type-id="${type.id}"
                         title="${type.name}">
                    </div>
                `).join('');
                swatchContainer.innerHTML = swatchesHTML;
                aethericOptions.classList.remove('hidden');
            } else {
                aethericOptions.classList.add('hidden');
            }
        }
        //endregion
        
        //region Unified interaction handlers
        function handleInteractionStart(clientX, clientY) {
            interactionStartX = clientX;
            interactionStartY = clientY;
            interactionMoved = false;

            if (brushSettings.enabled) {
                isBrushing = true;
                const worldCoords = getCoordsInWorld(clientX, clientY);
                lastBrushX = worldCoords.x;
                lastBrushY = worldCoords.y;
                
                // Handle single-click actions for brushes that support it
                if (brushSettings.brushType === 'aetheric' && brushSettings.aethericMode === 'pulse' && !isPaused) {
                    applyAethericBrush(worldCoords.x, worldCoords.y, 0, 0, true);
                } else {
                    applyBrush(worldCoords.x, worldCoords.y, 0, 0);
                }

            } else {
                isPanning = true;
                canvas.style.cursor = 'grabbing';
                lastPanX = clientX;
                lastPanY = clientY;
            }
        }

        function handleInteractionMove(clientX, clientY) {
            if (!interactionMoved) {
                const dx = clientX - interactionStartX;
                const dy = clientY - interactionStartY;
                if (Math.sqrt(dx * dx + dy * dy) > 10) { // Drag threshold
                    interactionMoved = true;
                }
            }

            if (isBrushing) {
                const worldCoords = getCoordsInWorld(clientX, clientY);
                const dx = worldCoords.x - lastBrushX;
                const dy = worldCoords.y - lastBrushY;
                
                applyBrush(worldCoords.x, worldCoords.y, dx, dy);

                lastBrushX = worldCoords.x;
                lastBrushY = worldCoords.y;
            } else if (isPanning) {
                canvas.style.cursor = 'grabbing';
                const dx = clientX - lastPanX;
                const dy = clientY - lastPanY;
                viewTransform.preMultiplySelf(new DOMMatrix().translate(dx, dy));
                lastPanX = clientX;
                lastPanY = clientY;
            }
        }
        //endregion

        //region REVISED: Prevents UI toggle when brush is active
        function handleInteractionEnd() {
            // If the pointer didn't move significantly and a brush is NOT active, it was a tap.
            if (!interactionMoved && !brushSettings.enabled) {
                toggleUI();
            }

            isBrushing = false;
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = brushSettings.enabled ? 'crosshair' : 'grab';
            }
        }

        function getCoordsInWorld(clientX, clientY) {
            const invertedMatrix = viewTransform.inverse();
            const rect = canvas.getBoundingClientRect();
            const cssX = clientX - rect.left;
            const cssY = clientY - rect.top;
            return new DOMPoint(cssX, cssY).matrixTransform(invertedMatrix);
        }

        function applyBrush(x, y, dx, dy) {
            if (isPaused) return;
            if (brushSettings.brushType === 'aetheric') {
                applyAethericBrush(x, y, dx, dy, false);
            } else if (brushSettings.brushType === 'effect') {
                applyEffectBrush(x, y, dx, dy);
            }
        }
        
        function applyAethericBrush(x, y, dx, dy, isClick) {
            const type = particleTypes.find(t => t.id === brushSettings.selectedParticleTypeID);
            if (!type || type.isSpecial) return;
            const speed = Math.sqrt(dx * dx + dy * dy);

            switch(brushSettings.aethericMode) {
                case 'stream':
                    createParticle(x, y, type, { size: brushSettings.size / 2 });
                    break;
                case 'spray':
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * brushSettings.size * 1.5;
                        const sprayX = x + Math.cos(angle) * radius;
                        const sprayY = y + Math.sin(angle) * radius;
                        createParticle(sprayX, sprayY, type, { size: brushSettings.size * 0.3 });
                    }
                    break;
                case 'pulse':
                    if (isClick) {
                        const count = 30;
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            const pulseSpeed = 2;
                            createParticle(x, y, type, {
                                size: brushSettings.size / 2.5,
                                vx: Math.cos(angle) * pulseSpeed,
                                vy: Math.sin(angle) * pulseSpeed
                            });
                        }
                    }
                    break;
                case 'calligrapher':
                    const size = Math.max(2, brushSettings.size * (1 - Math.min(1, speed / 15)));
                    createParticle(x, y, type, { size: size });
                    break;
            }
        }
        //endregion
        
        //region REVISED: Added new effect brush logic
        function applyEffectBrush(x, y, dx, dy) {
            const brushRadiusSq = brushSettings.size * brushSettings.size;
            const paintStrength = 5;

            switch(brushSettings.effectMode) {
                case 'velocity':
                    particles.forEach(p => {
                        const distSq = (p.x - x)**2 + (p.y - y)**2;
                        if(distSq < brushRadiusSq) {
                            p.vx = dx * paintStrength;
                            p.vy = dy * paintStrength;
                        }
                      });
                    break;
                case 'typeMutator': {
                    const newType = particleTypes.find(t => t.id === brushSettings.selectedParticleTypeID);
                    if (!newType || newType.isSpecial) return;
                    particles.forEach(p => {
                        const distSq = (p.x - x)**2 + (p.y - y)**2;
                        if (distSq < brushRadiusSq) {
                            p.typeId = newType.id;
                            p.type = newType;
                            p.color = newType.color;
                        }
                    });
                    break;
                }
                case 'shrapnel': {
                    const particlesToShatter = [];
                    particles.forEach(p => {
                        if (p.isGhost) return;
                        const distSq = (p.x - x)**2 + (p.y - y)**2;
                        if (distSq < brushRadiusSq) {
                            particlesToShatter.push(p.id);
                        }
                    });

                    if (particlesToShatter.length > 0) {
                        let newFragments = [];
                        particles = particles.filter(p => {
                            if (particlesToShatter.includes(p.id)) {
                                shatter(p, newFragments, 5);
                                return false; // Remove
                            }
                            return true; // Keep
                        });
                        newFragments.forEach(data => createParticle(data.x, data.y, data.type, data.options));
                    }
                    break;
                }
                case 'eraser': {
                    const particlesToErase = new Set();
                    particles.forEach(p => {
                        const distSq = (p.x - x)**2 + (p.y - y)**2;
                        if (distSq < brushRadiusSq) {
                            particlesToErase.add(p.id);
                        }
                    });
                    if (particlesToErase.size > 0) {
                        particles = particles.filter(p => !particlesToErase.has(p.id));
                    }
                    break;
                }
            }
        }
        
        function saveBrushSettings() {
             try {
                 localStorage.setItem('cas_brushSettings', JSON.stringify(brushSettings));
             } catch (e) {
                 console.error("Could not save brush settings to localStorage:", e);
             }
        }

        function loadBrushSettings() {
             try {
                 const saved = localStorage.getItem('cas_brushSettings');
                 if (saved) {
                     const loaded = JSON.parse(saved);
                     // Create a default settings object to merge with, preventing old/invalid properties
                     const defaultBrush = {
                         enabled: false,
                         brushType: 'aetheric',
                         aethericMode: 'stream',
                         effectMode: 'velocity',
                         selectedParticleTypeID: 0,
                         size: 20,
                         strength: 1,
                     };
                     brushSettings = { ...defaultBrush, ...loaded };
                 }
             } catch (e) {
                 console.error("Could not load brush settings from localStorage:", e);
             }
        }
        //endregion

        /** NEW: Handles the interaction between geometry and the "Illusory Walls" anomaly. */
        function handleGeometryAnomalyInteraction(shape) {
            const wrapWallsAnomaly = ALL_ANOMALIES.find(e => e.id === 'wrap_walls');
            if (!wrapWallsAnomaly) return;
            
            // If the active anomaly is 'wrap_walls', we don't need to do anything special.
            // But if we switch TO the torus, we need to force the wrap behavior.
            if (shape === 'torus') {
                spaceRules.boundary = 'wrap';
            } else {
                // If the current anomaly is NOT wrap_walls, set boundary back to bounce.
                if (!activeAnomaly || activeAnomaly.id !== 'wrap_walls') {
                    spaceRules.boundary = 'bounce';
                }
            }
        }

        //region --- NEW: Template Functionality ---
        function applyTemplate(templateId) {
            const template = templates[templateId];
            if (!template) return;

           const s = template.settings;

            // Update state variables
            backgroundSettings.color = s.backgroundColor;
            cosmeticRules.backgroundStyle = s.backgroundStyle;
            cosmeticRules.particleStyle = s.particleStyle;
            cosmeticRules.particleEffect = s.particleEffect;
            cosmeticRules.colorPalette = s.colorPalette;

            // Set this template as active *before* updating UI
            activeTemplateId = templateId;
            saveActiveTemplate();
            
            // Update the UI to reflect the new state
            setupCosmeticControls(); // This function now handles all button updates

            // Apply colors and save settings
            applyCurrentPalette();
            saveBackgroundSettings();
        }

        function saveActiveTemplate() {
            try {
                localStorage.setItem('cas_activeTemplateId', activeTemplateId || '');
            } catch (e) {
                console.error("Could not save active template ID", e);
            }
        }

        function loadActiveTemplate() {
            try {
                const saved = localStorage.getItem('cas_activeTemplateId');
                // Default to 'template-basic' if nothing is saved
                activeTemplateId = saved || 'template-basic';
            } catch (e) {
                console.error("Could not load active template ID", e);
                activeTemplateId = 'template-basic';
            }
        }
        //endregion
        
        //region --- SPECIAL ANOMALY HELPERS ---

        function applySpecialAnomalyToInitialConditions(conditions) {
            const { specialAnomalyId, particleTypes: currentTypes } = conditions;
            const newTypeId = currentTypes.length;
            let specialType = {
                id: newTypeId,
                baseSize: 15,
                massFactor: 50, // Very heavy
                chargeFactor: 0,
                baseLifespanFactor: Number.MAX_SAFE_INTEGER, // Effectively infinite
                isSpecial: true
            };

            switch (specialAnomalyId) {
                case 'strange_attractor':
                    specialType.name = 'Strange Attractor';
                    specialType.color = '#FFFFFF';
                    showAnomalyModal({ id: 'strange_attractor', name: 'Strange Attractor', isSpecial: true });
                    break;
                case 'strange_repulsor':
                    specialType.name = 'Strange Repulsor';
                    specialType.color = '#000000';
                    showAnomalyModal({ id: 'strange_repulsor', name: 'Strange Repulsor', isSpecial: true });
                    break;
                case 'odd_particle':
                    specialType.name = 'The Odd Particle';
                    specialType.color = '#FF00FF'; // Bright magenta
                    specialType.massFactor = 1000; // Effectively immovable
                    showAnomalyModal({ id: 'odd_particle', name: 'The Odd Particle', isSpecial: true });
                    break;
            }
            conditions.particleTypes.push(specialType);
        }

        function overrideInteractionRulesForSpecialAnomaly(conditions) {
            const { specialAnomalyId, particleTypes: allTypes, interactionRules: rules } = conditions;
            const specialType = allTypes.find(t => t.isSpecial);
            if (!specialType) return;

            const specialTypeId = specialType.id;

            // Set how the special particle interacts with all other types
            for (const otherType of allTypes) {
                let behavior, force, range;
                switch (specialAnomalyId) {
                    case 'strange_attractor':
                        behavior = 'attract';
                        force = 50; // Huge attraction force
                        range = worldWidth * 2; // Affects the whole map
                        break;
                    case 'strange_repulsor':
                        behavior = 'repel';
                        force = 50; // Huge repulsion force
                        range = worldWidth * 2;
                        break;
                    case 'odd_particle':
                        behavior = 'ignore'; // The interaction is handled in handleContact
                        force = 0;
                        range = 0;
                        break;
                }

                // Interaction from special particle to others
                rules[specialTypeId][otherType.id] = { behavior, force, range };
                // Interaction from others to special particle
                if (otherType.id !== specialTypeId) {
                    rules[otherType.id][specialTypeId] = { behavior, force, range };
                }
            }
        }
        //endregion
        
        // --- Initialize App ---
        function initializeApp() {
            loadFundamentalSettings();
            loadInherentLawSettings();
            loadBackgroundSettings();
            loadBrushSettings();
            loadAnomalySettings();
            loadAutoResetSettings();
            loadAudioSettings();
            loadActiveTemplate();
            buildControls();
            addAllEventListeners();
            
            const loadingOverlay = document.getElementById('loading-overlay');
            const titleOverlay = document.getElementById('title-screen-overlay');
            const startGameBtn = document.getElementById('start-game-btn');

            startGameBtn.addEventListener('click', () => {
                titleOverlay.classList.add('hidden');
                if (isPaused) {
                    togglePause();
                }
            });

            // Add listeners for the dynamically created brush toolbar
            brushToolbar.addEventListener('click', (e) => {
                const target = e.target;
                if (target.matches('.toolbar-button')) {
                    brushSettings.brushType = target.dataset.type;
                    updateBrushUI();
                    saveBrushSettings();
                }
                if (target.matches('.particle-swatch')) {
                    const selectedId = parseInt(target.dataset.typeId, 10);
                    const selectedType = particleTypes.find(t => t.id === selectedId);
                    // Prevent selecting special particles with the brush
                    if (selectedType && !selectedType.isSpecial) {
                        brushSettings.selectedParticleTypeID = selectedId;
                        updateBrushUI();
                        saveBrushSettings();
                    }
                }
            });

            // Apply the loaded or default template settings for the background simulation
            applyTemplate(activeTemplateId);
            setup();
            
            // FIX: Correctly initialize to a paused state for the title screen.
            isPaused = true; 
            pauseIcon.classList.add('hidden');
            playIcon.classList.remove('hidden');
            
            // Start the loading -> title sequence
            setTimeout(() => {
                loadingOverlay.style.opacity = '0';
                titleOverlay.classList.remove('hidden');
                setTimeout(() => loadingOverlay.style.display = 'none', 500); // Remove loader from DOM after transition
            }, 500); // Loader visible for 0.5s


            // Final UI state check on load
            brushShortcutBtn.classList.toggle('active', brushSettings.enabled);
            canvas.classList.toggle('brush-active', brushSettings.enabled);
            updateActiveButton(gameSettingsPanel.querySelector('#anomalyFrequencyGroup'), String(anomalySettings.frequency), 'value');
            updateActiveButton(gameSettingsPanel.querySelector('#autoResetGroup'), String(autoResetSettings.threshold), 'value');
            const slider = document.getElementById('audio-reactivity-slider');
            const label = document.getElementById('audio-reactivity-label');
            if (slider && label) {
                slider.value = audioVisualizerState.reactivity;
                label.textContent = `${parseFloat(slider.value).toFixed(1)}x`;
            }
        }
      
        initializeApp();

      </script>
</body>
</html>